## initialization
tmax <- 70 ## length of time series
dt <- 0.1 ## size of time steps
seed <- 1234320 ## RNG seed
N0 <- 10 ## initial population size
traitmean <- 1 ## initial mean of trait distribution
traitcv <- 0.1 ## initial coefficient of variation of trait distribution
h2 <- 0.8 ## heritability

## logistic equation parameters
bs <- 0.01
ds <- 0.01
slope <- 1/6

## try simulating with a different RNG seed
seeds <- vector()
results <- vector('list', length=3)
for (i in 1:3) {
    seed <- floor(runif(1,1,1e6))
    seeds[i] <- seed
    results[[i]] <- simulate_GEM(seed, 200, dt, N0, traitmean, traitcv, h2, bs, ds, slope)
}

par(mfrow=c(1,3))
plot(seq(0,200,dt), lapply(results[[1]],length), type='l', xlab='time', ylab='pop size')
lines(seq(0,200,dt), lapply(results[[2]],length), col='lightblue')
lines(seq(0,200,dt), lapply(results[[3]],length), col='orange')

plot(seq(0,200,dt), lapply(results[[1]],mean), type='l', xlab='time', ylab='trait mean')
lines(seq(0,200,dt), lapply(results[[2]],mean), col='lightblue')
lines(seq(0,200,dt), lapply(results[[3]],mean), col='orange')

plot(seq(0,200,dt), lapply(results[[1]],var), type='l', xlab='time', ylab='trait var')
lines(seq(0,200,dt), lapply(results[[2]],var), col='lightblue')
lines(seq(0,200,dt), lapply(results[[3]],var), col='orange')
dev.copy2pdf(file="~/Desktop/GEM_individual_run_comparison.pdf")

## BUT THERE ARE OFTEN PROBLEMS
seed <- 599354 ## generates a problematic dataset - diagnose!

pick_individuals <- function(N0, traitmean, traitsd) {
    mu <- log(traitmean^2 / sqrt((traitsd)^2+traitmean^2))
    sigma <- sqrt(log(traitsd^2 + 1))
    ## record this initial distribution in the output
    return(rlnorm(N0, meanlog=mu, sdlog=sigma))
}

## John's method of GEM
simulate_GEM <- function(seed, tmax, dt, N0, traitmean, traitcv, h2, bs, ds, slope) {
    ## set RNG seed
    set.seed(seed)
    ## initialize
    times <- seq(0,tmax,by=dt)
    t <- 0 ## current time
    ## storage for time series; at each timestep, record the traits of every individual in the population
    output <- vector("list", length(times))

    ## draw initial trait distribution from lognormal with meanlog and sdlog given by traitmean and traitcv
    output[[1]] <- pick_individuals(N0, traitmean, traitsd=traitmean*traitcv)
    ## also record it in a vector called 'currentstate' that records the current state of the system only
    currentstate <- output[[1]]

    i <- 1 ## how many things in the output file?
    while (t < tmax) {
        if (length(currentstate) > 0) { ## as long as population size is > 0 pick an individual
            ind <- sample(1:length(currentstate),1)
            trait <- currentstate[ind]
            N <- length(currentstate)
            ## set up rates for each possible event
            ## birth
            brate <- (trait - bs*N)*N
            ## death (specified by relationship between birth and death)
            d <- slope*trait
            drate <- (d + ds*N)*N
            events <- c(brate,drate)

            ## wheel of fortune
            wheel <- cumsum(events)/sum(events)
            ## which event happens?
            event <- min(which(runif(1) < wheel))

            if (event==1) { ## birth
                ## compute the trait of the offspring
                ## offspring trait distribution mean
                trait_parent <- (1-h2)*mean(output[[1]]) + h2*trait
                ## offspring trait distribution standard deviation given by CV, which is constant
                off_std <- sqrt(1-h2^2)*((1-h2)*sd(output[[1]])+h2*sd(currentstate))
                newtrait <- pick_individuals(1, trait_parent, off_std)
                ## add this individual to the current state vector
                currentstate <- c(currentstate, newtrait)
            }
            else  ## death
                currentstate <- currentstate[-ind]

            ## advance time
            t <- t + exp(-1/sum(events))/sum(events)

            if (is.na(t))
                print(currentstate)
            ## record in the output if necessary
            if (t > times[i+1]) {## if time has passed the next recording time
                output[[i+1]] <- currentstate ## record the system state
                i <- i + 1 ## advance to the next timestep
            }
        }
    }
    return(output)
}

## i think the offspring traits are specified incorrectly. It should be impossible to run out of variation. Even when sd(currentstate) goes to 0, there should be variation be generated by mutation/demographic heterogeneity. Basically, this model makes individual birth phenotypes dependent on a population-level property. That seems weird.

## here is an alternative method that simply says that there is some amount of stochasticity that is generated regardless of anything else.

simulate_GEM_2 <- function(seed, tmax, dt, N0, traitmean, traitcv, h2, bs, ds, slope) {
    ## set RNG seed
    set.seed(seed)
    ## initialize
    times <- seq(0,tmax,by=dt)
    t <- 0 ## current time
    ## storage for time series; at each timestep, record the traits of every individual in the population
    output <- vector("list", length(times))

    ## draw initial trait distribution from lognormal with meanlog and sdlog given by traitmean and traitcv
    output[[1]] <- pick_individuals(N0, traitmean, traitsd=traitmean*traitcv)
    ## also record it in a vector called 'currentstate' that records the current state of the system only
    currentstate <- output[[1]]

    i <- 1 ## how many things in the output file?
    while (t < tmax) {
        if (length(currentstate) > 0) { ## as long as population size is > 0 pick an individual
            ind <- sample(1:length(currentstate),1)
            trait <- currentstate[ind]
            N <- length(currentstate)
            ## set up rates for each possible event
            ## birth
            brate <- (trait - bs*N)*N
            ## death (specified by relationship between birth and death)
            d <- slope*trait
            drate <- (d + ds*N)*N
            events <- c(brate,drate)

            ## wheel of fortune
            wheel <- cumsum(events)/sum(events)
            ## which event happens?
            event <- min(which(runif(1) < wheel))

            if (event==1) { ## birth
                ## compute the trait of the offspring
                ## offspring trait distribution mean
                trait_parent <- (1-h2)*mean(currentstate) + h2*trait
                ## offspring trait distribution standard deviation given by CV, which is constant
                off_std <- trait_parent*traitcv
                newtrait <- pick_individuals(1, trait_parent, off_std)
                ## add this individual to the current state vector
                currentstate <- c(currentstate, newtrait)
            }
            else  ## death
                currentstate <- currentstate[-ind]

            ## advance time
            t <- t + exp(-1/sum(events))/sum(events)

            ## record in the output if necessary
            if (t > times[i+1]) {## if time has passed the next recording time
                output[[i+1]] <- currentstate ## record the system state
                i <- i + 1 ## advance to the next timestep
            }
        }
    }
    return(output)
}

## if you eliminate that, then evolution blows up, as expected
output <- simulate_GEM_2(234124, 27, dt, N0, traitmean, traitcv, h2, bs, ds, slope)
N <- unlist(lapply(output, length))
tm <- unlist(lapply(output, mean)) ## trait means
tv <- unlist(lapply(output, var)) ## trait variance
par(mfrow=c(1,3))
plot(seq(0,(length(N)-1)*dt,by=dt), N, type='l', xlab='time', ylab='pop size')
plot(seq(0,(length(tm)-1)*dt,by=dt), tm, type='l', xlab='time', ylab='trait mean')
plot(seq(0,(length(tv)-1)*dt,by=dt), tv, type='l', xlab='time', ylab='trait variance')






















## here is a version that should produce an ESS

simulate_GEM_ESS <- function(seed, tmax, dt, N0, traitmean, traitcv, h2, bs, ds, slope) {
    ## set RNG seed
    set.seed(seed)
    ## initialize
    times <- seq(0,tmax,by=dt)
    t <- 0 ## current time
    ## storage for time series; at each timestep, record the traits of every individual in the population
    output <- vector("list", length(times))

    ## draw initial trait distribution from lognormal with meanlog and sdlog given by traitmean and traitcv
    output[[1]] <- pick_individuals(N0, traitmean, traitsd=traitmean*traitcv)
    ## also record it in a vector called 'currentstate' that records the current state of the system only
    currentstate <- output[[1]]

    i <- 1 ## how many things in the output file?
    while (t < tmax) {
        if (length(currentstate) > 0) { ## as long as population size is > 0 pick an individual
            ind <- sample(1:length(currentstate),1)
            trait <- currentstate[ind]
            N <- length(currentstate)
            ## set up rates for each possible event
            ## birth
            brate <- (trait - bs*N)*N
            ## death (specified by relationship between birth and death)
            d <- slope*trait^2
            drate <- (d + ds*N)*N
            events <- c(brate,drate)

            ## wheel of fortune
            wheel <- cumsum(events)/sum(events)
            ## which event happens?
            event <- min(which(runif(1) < wheel))

            if (event==1) { ## birth
                ## compute the trait of the offspring
                ## offspring trait distribution mean
                trait_parent <- (1-h2)*mean(currentstate) + h2*trait
                ## offspring trait distribution standard deviation given by CV, which is constant
                off_std <- trait_parent*traitcv
                newtrait <- pick_individuals(1, trait_parent, off_std)
                ## add this individual to the current state vector
                currentstate <- c(currentstate, newtrait)
            }
            else  ## death
                currentstate <- currentstate[-ind]

            ## advance time
            t <- t + exp(-1/sum(events))/sum(events)

            ## record in the output if necessary
            if (t > times[i+1]) {## if time has passed the next recording time
                output[[i+1]] <- currentstate ## record the system state
                i <- i + 1 ## advance to the next timestep
            }
        }
    }
    return(output)
}

## quantitative genetics model
qg_model <- function(t, y, pars) {
    bs <- pars["bs"]
    ds <- pars["ds"]
    slope <- pars["slope"]
    V <- pars["V"]

    N <- y[1]
    b <- y[2]
    d <- slope*b^2
    dNdt <- (b-bs*N)*N-(d+ds*N)*N
    dbdt <- V*(1-2*b*slope)
    list(c(dNdt,dbdt))
}


traitcv <- 0.1
results <- vector(mode='list', length=20)
for (i in 1:20) {
    print(i)
    results[[i]] <- simulate_GEM_ESS(floor(runif(1,1,1e7)), 100, dt, N0, traitmean, traitcv, h2, bs, ds, slope)
}
out2 <- lsoda(y=c(10,1), times=seq(0,100,0.1), func=qg_model, parms=c(bs=bs, ds=ds, slope=slope, V=traitcv))

par(mfrow=c(1,2))
## calculate mean population dynamics across the simulations
lapply(results, function(res) lapply(res, length) %>% unlist) %>% unlist %>% matrix(., ncol=20, byrow=FALSE) %>% as.data.frame -> out
out$mean <- apply(out, 1, mean)
plot.new()
plot.window(xlim=c(1,nrow(out)), ylim=range(out))
axis(1); axis(2); box('plot')
mtext(side=1, line=3, "time")
mtext(side=2, line=3, "pop size")
for (i in 1:20)
    lines(out[,i], col=gray(0.7))
lines(out$mean, col='blue', lwd=2)
lines(out2[,2], col='red', lwd=2)

## calculate mean trait dynamics across the simulations
lapply(results, function(res) lapply(res, mean) %>% unlist) %>% unlist %>% matrix(., ncol=20, byrow=FALSE) %>% as.data.frame -> out
out$mean <- apply(out, 1, mean)
plot.new()
plot.window(xlim=c(1,nrow(out)), ylim=c(0,10))
axis(1); axis(2); box('plot')
mtext(side=1, line=3, "time")
mtext(side=2, line=3, "trait mean")
for (i in 1:20)
    lines(out[,i], col=gray(0.7))
lines(out$mean, col='blue', lwd=2)
lines(out2[,3], col='red', lwd=2)
