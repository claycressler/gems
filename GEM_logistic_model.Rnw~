\documentclass[12pt,reqno,final,pdftex]{amsart}
%% DO NOT DELETE OR CHANGE THE FOLLOWING TWO LINES!
%% $Revision$
%% $Date$
\usepackage[round,sort,elide]{natbib}
\usepackage{graphicx}
\usepackage{times}
\usepackage{rotating}
\usepackage{subfig}
\usepackage{color}
\newcommand{\aak}[1]{\textcolor{cyan}{#1}}
\newcommand{\mab}[1]{\textcolor{red}{#1}}
\newcommand{\cec}[1]{\textcolor{blue}{#1}}

\setlength{\textwidth}{6.25in}
\setlength{\textheight}{8.75in}
\setlength{\evensidemargin}{0in}
\setlength{\oddsidemargin}{0in}
\setlength{\topmargin}{-.35in}
\setlength{\parskip}{.1in}
\setlength{\parindent}{0.3in}

%% cleveref must be last loaded package
\usepackage[sort&compress]{cleveref}
\newcommand{\crefrangeconjunction}{--}
\crefname{figure}{Fig.}{Figs.}
\Crefname{figure}{Fig.}{Figs.}
\crefname{table}{Table}{Tables}
\Crefname{table}{Tab.}{Tables}
\crefname{equation}{Eq.}{Eqs.}
\Crefname{equation}{Eq.}{Eqs.}
\crefname{appendix}{Appendix}{Appendices}
\Crefname{appendix}{Appendix}{Appendices}
\creflabelformat{equation}{#2#1#3}

\theoremstyle{plain}
\newtheorem{thm}{Theorem}
\newtheorem{corol}[thm]{Corollary}
\newtheorem{prop}[thm]{Proposition}
\newtheorem{lemma}[thm]{Lemma}
\newtheorem{defn}[thm]{Definition}
\newtheorem{hyp}[thm]{Hypothesis}
\newtheorem{example}[thm]{Example}
\newtheorem{conj}[thm]{Conjecture}
\newtheorem{algorithm}[thm]{Algorithm}
\newtheorem{remark}{Remark}
\renewcommand\thethm{\arabic{thm}}
\renewcommand{\theremark}{}

\numberwithin{equation}{part}
\renewcommand\theequation{\arabic{equation}}
\renewcommand\thesection{\arabic{section}}
\renewcommand\thesubsection{\thesection.\arabic{subsection}}
\renewcommand\thefigure{\arabic{figure}}
\renewcommand\thetable{\arabic{table}}
\renewcommand\thefootnote{\arabic{footnote}}

\newcommand\scinot[2]{$#1 \times 10^{#2}$}
\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\pkg}[1]{\textsf{#1}}
\newcommand{\dlta}[1]{{\Delta}{#1}}
\newcommand{\Prob}[1]{\mathbb{P}\left[#1\right]}
\newcommand{\Expect}[1]{\mathbb{E}\left[#1\right]}
\newcommand{\Var}[1]{\mathrm{Var}\left[#1\right]}
\newcommand{\dd}[1]{\mathrm{d}{#1}}
\newcommand{\citetpos}[1]{\citeauthor{#1}'s \citeyearpar{#1}}

\begin{document}

<<setup,include=FALSE,cache=F>>=
require(knitr)
opts_chunk$set(
               progress=T,prompt=F,tidy=F,highlight=T,
               warning=F,message=F,error=F,
               results='hide',echo=F,cache=T,
               size='scriptsize',
               fig.path='figure/',fig.lp="fig:",
               fig.align='left',
               fig.show='asis',
               fig.height=4,fig.width=6.83,
               out.width="\\linewidth",
               dpi=150,
               dev=c('png','tiff'),
               dev.args=list(
                 png=list(bg='transparent'),
                 tiff=list(compression='lzw')
                 )
               )

scinot <- function (x, digits = 2, type = c("expression","latex")) {
  type <- match.arg(type)
  x <- signif(x,digits=digits)
  ch <- floor(log10(abs(x)))
  mn <- x/10^ch
  switch(type,
         expression={
           bquote(.(mn)%*%10^.(ch))
         },
         latex={
           paste0("\\scinot{",mn,"}{",ch,"}")
         }
         )
}

require(xtable)

options(scipen=-1)

options(
        xtable.caption.placement="top",
        xtable.include.rownames=FALSE
        )

@


<<>>=
## initialization
tmax <- 70 ## length of time series
dt <- 0.1 ## size of time steps
seed <- 1234320 ## RNG seed
N0 <- 10 ## initial population size
traitmean <- 1 ## initial mean of trait distribution
traitcv <- 0.1 ## initial coefficient of variation of trait distribution
h2 <- 0.8 ## heritability

## logistic equation parameters
bs <- 0.01
ds <- 0.01
slope <- 1/6

pick_individuals <- function(N0, traitmean, traitsd) {
    mu <- log(traitmean^2 / sqrt((traitsd)^2+traitmean^2))
    sigma <- sqrt(log(traitsd^2 + 1))
    ## record this initial distribution in the output
    return(rlnorm(N0, meanlog=mu, sdlog=sigma))
}


logistic_GEM <- function(seed, tmax, dt, N0, traitmean, traitcv, h2, bs, ds, slope) {

    ## set RNG seed
    set.seed(seed)
    ## initialize
    times <- seq(0,tmax,by=dt)
    t <- 0 ## current time
    ## storage for time series; at each timestep, record the traits of every individual in the population
    output <- vector("list", length(times))

    ## draw initial trait distribution from lognormal with meanlog and sdlog given by traitmean and traitcv
    output[[1]] <- pick_individuals(N0, traitmean, traitsd=traitmean*traitcv)
    ## also record it in a vector called 'currentstate' that records the current state of the system only
    currentstate <- output[[1]]

    i <- 1 ## how many things in the output file?
    while (t < tmax) {
        if (length(currentstate) > 0) { ## as long as population size is > 0 pick an individual
            ind <- sample(1:length(currentstate),1)
            trait <- currentstate[ind]
            N <- length(currentstate)
            ## set up rates for each possible event
            ## birth
            brate <- (trait - bs*N)*N
            ## death (specified by tradeoff between birth and death)
            d <- slope*trait^2
            drate <- (d + ds*N)*N
            events <- c(brate,drate)

            ## wheel of fortune
            wheel <- cumsum(events)/sum(events)
            ## which event happens?
            event <- min(which(runif(1) < wheel))

            if (event==1) { ## birth
                ## compute the trait of the offspring
                ## offspring trait distribution mean
                trait_parent <- (1-h2)*mean(currentstate) + h2*trait
                off_std <- sqrt(1-h2^2)*((1-h2)*sd(output[[1]])+h2*sd(currentstate))
                newtrait <- pick_individuals(1, trait_parent, off_std)
                ## add this individual to the current state vector
                currentstate <- c(currentstate, newtrait)
            }
            else  ## death
                currentstate <- currentstate[-ind]

            ## advance time
            t <- t + exp(-1/sum(events))/sum(events)

            ## record in the output if necessary
            if (t > times[i+1]) {## if time has passed the next recording time
                output[[i+1]] <- currentstate ## record the system state
                i <- i + 1 ## advance to the next timestep
            }
        }
    }
    return(output)
}

## here is an alternative version of the model where, instead of randomly choosing the individual and then creating the wheel of fortune based on its traits, instead computes a wheel of fortune for all possible events that occur to *any* individual and then uses the RNG to choose both the individual and the event
logistic_GEM2 <- function(seed, tmax, dt, N0, traitmean, traitcv, h2, bs, ds, slope) {

    ## set RNG seed
    set.seed(seed)
    ## initialize
    times <- seq(0,tmax,by=dt)
    t <- 0 ## current time
    ## storage for time series; at each timestep, record the traits of every individual in the population
    output <- vector("list", length(times))

    ## draw initial trait distribution from lognormal with meanlog and sdlog given by traitmean and traitcv
    output[[1]] <- pick_individuals(N0, traitmean, traitsd=traitmean*traitcv)
    ## also record it in a vector called 'currentstate' that records the current state of the system only
    currentstate <- output[[1]]

    i <- 1 ## how many things in the output file?
    while (t < tmax) {
        if (length(currentstate) > 0) { ## as long as population size is > 0 pick an individual
            ## wheel of fortune
            N <- length(currentstate)
            brates <- (currentstate - bs*N)*N
            d <- slope*currentstate^2
            drates <- (d + ds*N)*N
            ## wheel is set up with births first, then deaths
            events <- c(brates,drates)
            wheel <- cumsum(events)/sum(events)
            rand <- runif(1)
            ## who does the event happen to?
            ind <- ifelse(min(which(rand < wheel)) <= N,
                          min(which(rand < wheel)),
                          min(which(rand < wheel))-N)
            ## was the event a birth or death?
            event <- ifelse(rand <= sum(brates)/sum(events),
                            1, ## birth
                            2) ## death

            if (event==1) { ## birth
                ## compute the trait of the offspring
                ## offspring trait distribution mean
                trait_parent <- (1-h2)*mean(currentstate) + h2*currentstate[ind]
                off_std <- sqrt(1-h2^2)*((1-h2)*sd(output[[1]])+h2*sd(currentstate))
                newtrait <- pick_individuals(1, trait_parent, off_std)
                ## add this individual to the current state vector
                currentstate <- c(currentstate, newtrait)
            }
            else  ## death
                currentstate <- currentstate[-ind]

            ## advance time
            t <- t + exp(-1/sum(events))/sum(events)

            ## record in the output if necessary
            if (t > times[i+1]) {## if time has passed the next recording time
                output[[i+1]] <- currentstate ## record the system state
                i <- i + 1 ## advance to the next timestep
            }
        }
    }
    return(output)
}


## quantitative genetics model (here assuming an accelerating trade-off that will produce an ESS
qg_model <- function(t, y, pars) {
    bs <- pars["bs"]
    ds <- pars["ds"]
    slope <- pars["slope"]
    V <- pars["V"]

    N <- y[1]
    b <- y[2]
    d <- slope*b^2
    dNdt <- (b-bs*N)*N-(d+ds*N)*N
    dbdt <- V*(1-2*b*slope)
    list(c(dNdt,dbdt))
}
@

The first thing I want to consider is a comparison of two methods of simulating a GEM.
The first is the classic GEM, which chooses an individual at random, uses a Monte Carlo algorithm to determine what happens to it based on the individual's traits, and then advances time a random amount based on the total rate of events for that individual.
The second method modifies the algorithm by creating the ``wheel of fortune'' using the rates for every individual in the population, and then using the Monte Carlo algorithm to choose both an individual and an event from a single ``spin'' of the wheel.
Obviously, time will advance much more slowly in the second model because the timestep is chosen using the code exp(-1/sum(events))/sum(events): since the second method sums across all events (births and deaths) for every individual in the population, the denominator is a very large number in the second method.
Fig. \ref{fig:methodcomp} shows a comparison of the dynamics for the two models for an initial CV of 0.1 and a heritability of 0.8.
It is clear that the second method (in red) shows much more high intensity fluctuation around the carrying capacity (top row) and also evolves further towards the ESS trait value (ESS = 3, bottom row), although neither actually gets very close.

Fig. \ref{fig:methodcomp2} shows a comparison of the dynamics for the two models for an initial CV of 0.2 and a heritability of 0.9.
Here, you see a similar pattern for the population dynamics, but the trait dynamics are really different.
The first method shows wild fluctuations in the trait dynamics, whereas the second shows much less wild excursions, but doesn't get much closer to the ESS than it did when the CV and heritability were lower.

The question is which method is actually better.
I'm not sure this question has an answer, but one way to think about it is to think about how time advances.
In the first method, the size of the timestep is independent of the number of individuals in the population.
The expected timestep size is given by
\begin{equation}
\exp(-1/(\bar{b}+\bar{d}))/(\bar{b}+\bar{d}),
\end{equation}
where $\bar{b}$ and $\bar{d}$ are the average birth and death rates for the population and $N$ is the total population size.
In the second method, the size of the timestep depends on the number of individuals in the population.
The expected timestep size is given by
\begin{equation}
\exp(-1/(N*(\bar{b}+\bar{d})))/(N*(\bar{b}+\bar{d}))
\end{equation}

My recollection is that, in the standard Gillespie algorithm, time advances proportional to the number of particles in the population.


<<methodcomp, fig.cap="GEM simulation for the original method.">>=

## low variation
## initialization
dt <- 0.1 ## size of time steps
N0 <- 10 ## initial population size
traitmean <- 1 ## initial mean of trait distribution
traitcv <- 0.1 ## initial coefficient of variation of trait distribution
h2 <- 0.8 ## heritability

## logistic equation parameters
bs <- 0.01
ds <- 0.01
slope <- 1/6
tmax <- 50

out1 <- logistic_GEM(23412, tmax, dt, N0, traitmean, traitcv, h2, bs, ds, slope)
out2 <- logistic_GEM2(23412, tmax, dt, N0, traitmean, traitcv, h2, bs, ds, slope) ## much, much slower because time advances much more slowly

par(mfrow=c(2,2), mar=c(4,4,0.5,0.5), oma=rep(0,4))
plot(seq(0,tmax,dt), lapply(out1, length) %>% unlist, type='l', xlab="time", ylab="pop size")
plot(seq(0,tmax,dt), lapply(out2, length) %>% unlist, col=2, type='l', xlab="time", ylab="pop size")

plot(seq(0,tmax,dt), lapply(out1, mean) %>% unlist, type='l', xlab="time", ylab="trait mean")
plot(seq(0,tmax,dt), lapply(out2, mean) %>% unlist, col=2, type='l', xlab="time", ylab="trait mean")
@


<<methodcomp2, fig.cap="GEM simulation for the second method.">>=
traitcv <- 0.2 ## initial coefficient of variation of trait distribution
h2 <- 0.9 ## heritability
tmax <- 50

out3 <- logistic_GEM(23412, tmax, dt, N0, traitmean, traitcv, h2, bs, ds, slope)
out4 <- logistic_GEM2(23412, tmax, dt, N0, traitmean, traitcv, h2, bs, ds, slope) ## much, much slower because time advances much more slowly

par(mfrow=c(2,2), mar=c(4,4,0.5,0.5), oma=rep(0,4))
plot(seq(0,tmax,dt), lapply(out3, length) %>% unlist, type='l', xlab="time", ylab="pop size")
plot(seq(0,tmax,dt), lapply(out4, length) %>% unlist, col=2, type='l', xlab="time", ylab="pop size")

plot(seq(0,tmax,dt), lapply(out3, mean) %>% unlist, type='l', xlab="time", ylab="trait mean")
plot(seq(0,tmax,dt), lapply(out4, mean) %>% unlist, col=2, type='l', xlab="time", ylab="trait mean")
@

\newpage

The next thing I wanted to look at was the way that offspring traits are drawn.


<<>>=

h2 <- 0.8
traitcv <- 0.2
initialmean <- 1
currentmean <- 3
N0 <- 100

## generate a made-up initial state of the system
initialstate <- pick_individuals(N0, initialmean, traitsd=traitmean*traitcv)
currentstate <- pick_individuals(N0, currentmean, traitsd=traitmean*traitcv)

## generate the offspring distributions for parents with trait equal to the mean and in the tails of the distribution
trait1 <- currentstate[which.min(abs(currentstate-3))]
trait2 <- sort(currentstate)[5]
trait3 <- sort(currentstate)[95]

## parent traits, given heritability
trait_parent1 <- (1-h2)*mean(currentstate) + h2*trait1
trait_parent2 <- (1-h2)*mean(currentstate) + h2*trait2
trait_parent3 <- (1-h2)*mean(currentstate) + h2*trait3

## offspring trait standard deviation, given the initial state of the population and the current state
## note that this will be identical for all parents
off_std <- sqrt(1-h2^2)*((1-h2)*sd(initialstate)+h2*sd(currentstate))

## generate a bunch of offspring, just to see how much variability there is
off1 <- pick_individuals(100, trait_parent1, off_std)
off2 <- pick_individuals(100, trait_parent2, off_std)
off3 <- pick_individuals(100, trait_parent3, off_std)



@



<<eval=FALSE>>=

results <- vector(mode='list', length=20)
for (i in 1:20) {
    print(i)
    results[[i]] <- logistic_GEM(floor(runif(1,1,1e7)), 100, dt, N0, traitmean, traitcv, h2, bs, ds, slope, tradeoff="slope*trait^2")
}
library(deSolve)
out2 <- lsoda(y=c(10,1), times=seq(0,100,0.1), func=qg_model, parms=c(bs=bs, ds=ds, slope=slope, V=traitcv))

par(mfrow=c(1,2))
## calculate mean population dynamics across the simulations
lapply(results, function(res) lapply(res, length) %>% unlist) %>% unlist %>% matrix(., ncol=20, byrow=FALSE) %>% as.data.frame -> out
out$mean <- apply(out, 1, mean)
plot.new()
plot.window(xlim=c(1,nrow(out)), ylim=range(out))
axis(1); axis(2); box('plot')
mtext(side=1, line=3, "time")
mtext(side=2, line=3, "pop size")
for (i in 1:20)
    lines(out[,i], col=gray(0.7))
lines(out$mean, col='blue', lwd=2)
lines(out2[,2], col='red', lwd=2)

## calculate mean trait dynamics across the simulations
lapply(results, function(res) lapply(res, mean) %>% unlist) %>% unlist %>% matrix(., ncol=20, byrow=FALSE) %>% as.data.frame -> out
out$mean <- apply(out, 1, mean)
plot.new()
plot.window(xlim=c(1,nrow(out)), ylim=c(0,10))
axis(1); axis(2); box('plot')
mtext(side=1, line=3, "time")
mtext(side=2, line=3, "trait mean")
for (i in 1:20)
    lines(out[,i], col=gray(0.7))
lines(out$mean, col='blue', lwd=2)
lines(out2[,3], col='red', lwd=2)

@

\end{document}