lines(sort(b), (sort(b)-bs*length(b)-(s*sort(b)^2+ds*length(b)))/(sum(sort(b)-bs*length(b)+(s*sort(b)^2+ds*length(b)))), lwd=2, lty=2, col=2)
plot(sort(b), event_probs[order(b),"fitness"], xlab="Birth rate", ylab="P(birth)-P(death)", ylim=range(c(events_probs[,"fitness"],event_probs2[,"fitness"])))
## expected fitness
lines(sort(b), (sort(b)-bs*length(b)-(s*sort(b)^2+ds*length(b)))/((sort(b)-bs*length(b)+(s*sort(b)^2+ds*length(b)))*length(b)), lwd=2, lty=2)
points(sort(b), event_probs2[order(b),"fitness"], col=2)
lines(sort(b), (sort(b)-bs*length(b)-(s*sort(b)^2+ds*length(b)))/(sum(sort(b)-bs*length(b)+(s*sort(b)^2+ds*length(b)))), lwd=2, lty=2, col=2)
plot(sort(b), event_probs[order(b),"fitness"], xlab="Birth rate", ylab="P(birth)-P(death)", ylim=range(c(event_probs[,"fitness"],event_probs2[,"fitness"])))
## expected fitness
lines(sort(b), (sort(b)-bs*length(b)-(s*sort(b)^2+ds*length(b)))/((sort(b)-bs*length(b)+(s*sort(b)^2+ds*length(b)))*length(b)), lwd=2, lty=2)
points(sort(b), event_probs2[order(b),"fitness"], col=2)
lines(sort(b), (sort(b)-bs*length(b)-(s*sort(b)^2+ds*length(b)))/(sum(sort(b)-bs*length(b)+(s*sort(b)^2+ds*length(b)))), lwd=2, lty=2, col=2)
## Discrete time exponential
## n(t+1) = n(t) + b*n(t) - m*n(t) = n(t) + (b-m)*n(t) = n(t) + r*n(t)
t0 <- 0 ## initial time
tmax <- 100 ## final time
n0 <- 1 ## initial population size
r <- 0.1 ## per-capita growth rate
## initialize storage for population sizes
n <- vector(mode='numeric', length=length(0:tmax))
n[1] <- n0 ## store the initial population size
for (t in (t0+1):tmax) {
n[t+1] <- n[t] + r*n[t]
}
plot(x=t0:tmax, y=n, type='l')
K <- 100
for (t in (t0+1):tmax) {
n[t+1] <- n[t] + r*n[t]*(1-n[t]/K)
}
plot(x=t0:tmax, y=n, type='l')
r<- 1
K <- 100
for (t in (t0+1):tmax) {
n[t+1] <- n[t] + r*n[t]*(1-n[t]/K)
}
plot(x=t0:tmax, y=n, type='l')
r<- 1.5
K <- 100
for (t in (t0+1):tmax) {
n[t+1] <- n[t] + r*n[t]*(1-n[t]/K)
}
plot(x=t0:tmax, y=n, type='l')
r<- 2
K <- 100
for (t in (t0+1):tmax) {
n[t+1] <- n[t] + r*n[t]*(1-n[t]/K)
}
plot(x=t0:tmax, y=n, type='l')
tmax <- 1000 ## final time
n0 <- 1 ## initial population size
n <- vector(mode='numeric', length=length(0:tmax))
n[1] <- n0 ## store the initial population size
r<- 2
K <- 100
for (t in (t0+1):tmax) {
n[t+1] <- n[t] + r*n[t]*(1-n[t]/K)
}
plot(x=t0:tmax, y=n, type='l')
tmax <- 200 ## final time
n0 <- 1 ## initial population size
n <- vector(mode='numeric', length=length(0:tmax))
n[1] <- n0 ## store the initial population size
r<- 2
K <- 100
for (t in (t0+1):tmax) {
n[t+1] <- n[t] + r*n[t]*(1-n[t]/K)
}
plot(x=t0:tmax, y=n, type='l')
r<- 2.1
K <- 100
for (t in (t0+1):tmax) {
n[t+1] <- n[t] + r*n[t]*(1-n[t]/K)
}
plot(x=t0:tmax, y=n, type='l')
tmax <- 100 ## final time
n0 <- 1 ## initial population size
n <- vector(mode='numeric', length=length(0:tmax))
n[1] <- n0 ## store the initial population size
r<- 2.1
K <- 100
for (t in (t0+1):tmax) {
n[t+1] <- n[t] + r*n[t]*(1-n[t]/K)
}
plot(x=t0:tmax, y=n, type='l')
r<- 2.2
K <- 100
for (t in (t0+1):tmax) {
n[t+1] <- n[t] + r*n[t]*(1-n[t]/K)
}
plot(x=t0:tmax, y=n, type='l')
r<- 2.3
K <- 100
for (t in (t0+1):tmax) {
n[t+1] <- n[t] + r*n[t]*(1-n[t]/K)
}
plot(x=t0:tmax, y=n, type='l')
r<- 2.4
K <- 100
for (t in (t0+1):tmax) {
n[t+1] <- n[t] + r*n[t]*(1-n[t]/K)
}
plot(x=t0:tmax, y=n, type='l')
r<- 2.5
K <- 100
for (t in (t0+1):tmax) {
n[t+1] <- n[t] + r*n[t]*(1-n[t]/K)
}
plot(x=t0:tmax, y=n, type='l')
r<- 2.56
K <- 100
for (t in (t0+1):tmax) {
n[t+1] <- n[t] + r*n[t]*(1-n[t]/K)
}
plot(x=t0:tmax, y=n, type='l')
r<- 2.57
K <- 100
for (t in (t0+1):tmax) {
n[t+1] <- n[t] + r*n[t]*(1-n[t]/K)
}
plot(x=t0:tmax, y=n, type='l')
r<- 2.6
K <- 100
for (t in (t0+1):tmax) {
n[t+1] <- n[t] + r*n[t]*(1-n[t]/K)
}
plot(x=t0:tmax, y=n, type='l')
r<- 3
K <- 100
for (t in (t0+1):tmax) {
n[t+1] <- n[t] + r*n[t]*(1-n[t]/K)
}
plot(x=t0:tmax, y=n, type='l')
K <- 10
for (t in (t0+1):tmax) {
n[t+1] <- n[t] + r*n[t]*(1-n[t]/K)
}
plot(x=t0:tmax, y=n, type='l')
r<- 2
K <- 10
for (t in (t0+1):tmax) {
n[t+1] <- n[t] + r*n[t]*(1-n[t]/K)
}
plot(x=t0:tmax, y=n, type='l')
tmax <- 500
n0 <- 1 ## initial population size
## set up storage
store <- array(NA, dim=c(50,length(seq(1,3,0.01))))
for (j in 1:length(seq(1,3,0.01))) {
r <- seq(1,3,0.01)[j]
n <- vector(mode='numeric', length=length(0:tmax))
n[1] <- n0 ## store the initial population size
for (t in (t0+1):tmax) {
n[t+1] <- n[t] + r*n[t]*(1-n[t]/K)
}
## store the final 50 timepoints in column j
store[,j] <- tail(n,50)
}
plot(x=t0:tmax, y=n, type='l')
head(store)
plot.new()
plot.window(xlim=c(1,3), ylim=range(store))
axis(1); axis(2); box('plot')
for (j in 1:ncol(store)) {
points(rep(seq(1,3,0.01)[j],50), store[,j], pch=0.1)
}
plot.new()
plot.window(xlim=c(1,3), ylim=range(store))
axis(1); axis(2); box('plot')
for (j in 1:ncol(store)) {
points(rep(seq(1,3,0.01)[j],50), store[,j], pch=21, bg=1, cex=0.1)
}
## specify initial variable conditions
y <- c(n=1)
## specify the parameters
pars <- c(r=0.1, K=50)
## times to record
times <- seq(t0,tmax,1)
out <- ode(y=y, times=times, func=contExp, parms=pars, method="lsoda")
library(deSolve)
out <- ode(y=y, times=times, func=contExp, parms=pars, method="lsoda")
contLog <- function(t, y, pars) {
## pull out meaningful variable names
n <- y["n"]
## pull out meaningful parameter names
r <- pars["r"] ##
K <- pars["K"] ##
## differential equations
dndt <- r*n*(1-n/K)
return(list(c(dndt)))
}
out <- ode(y=y, times=times, func=contLog, parms=pars, method="lsoda")
conditions
plot(x=out[,"time"], y=out[,"n"], type='l')
## specify the parameters
pars <- c(r=0.01, K=50)
## times to record
times <- seq(t0,tmax,1)
out <- ode(y=y, times=times, func=contLog, parms=pars, method="lsoda")
plot(x=out[,"time"], y=out[,"n"], type='l')
## specify the parameters
pars <- c(r=1, K=50)
## times to record
times <- seq(t0,tmax,1)
out <- ode(y=y, times=times, func=contLog, parms=pars, method="lsoda")
plot(x=out[,"time"], y=out[,"n"], type='l')
## Discrete time logistic model
## n(t+1) = n(t) + b*n(t)*(1-n(t)/K)
t0 <- 0 ## initial time
tmax <- 100 ## final time
n0 <- 1 ## initial population size
r <- 0.1 ## per-capita growth rate
K <- 50
## initialize storage for population sizes
n <- vector(mode='numeric', length=length(0:tmax))
n[1] <- n0 ## store the initial population size
for (t in (t0+1):tmax) {
n[t+1] <- n[t] + r*n[t]*(1-n[t]/K)
}
plot(x=t0:tmax, y=n, type='l')
r <- 0.01 ## per-capita growth rate
K <- 50
## initialize storage for population sizes
n <- vector(mode='numeric', length=length(0:tmax))
n[1] <- n0 ## store the initial population size
for (t in (t0+1):tmax) {
n[t+1] <- n[t] + r*n[t]*(1-n[t]/K)
}
plot(x=t0:tmax, y=n, type='l')
r <- 1 ## per-capita growth rate
K <- 50
## initialize storage for population sizes
n <- vector(mode='numeric', length=length(0:tmax))
n[1] <- n0 ## store the initial population size
for (t in (t0+1):tmax) {
n[t+1] <- n[t] + r*n[t]*(1-n[t]/K)
}
plot(x=t0:tmax, y=n, type='l')
r <- 1.5 ## per-capita growth rate
K <- 50
## initialize storage for population sizes
n <- vector(mode='numeric', length=length(0:tmax))
n[1] <- n0 ## store the initial population size
for (t in (t0+1):tmax) {
n[t+1] <- n[t] + r*n[t]*(1-n[t]/K)
}
plot(x=t0:tmax, y=n, type='l')
r <- 1.7 ## per-capita growth rate
K <- 50
## initialize storage for population sizes
n <- vector(mode='numeric', length=length(0:tmax))
n[1] <- n0 ## store the initial population size
for (t in (t0+1):tmax) {
n[t+1] <- n[t] + r*n[t]*(1-n[t]/K)
}
plot(x=t0:tmax, y=n, type='l')
r <- 2 ## per-capita growth rate
K <- 50
n0 <- 1 ## initial population size
r <- 2 ## per-capita growth rate
K <- 50
## initialize storage for population sizes
n <- vector(mode='numeric', length=length(0:tmax))
n[1] <- n0 ## store the initial population size
for (t in (t0+1):tmax) {
n[t+1] <- n[t] + r*n[t]*(1-n[t]/K)
}
plot(x=t0:tmax, y=n, type='l')
r <- 2.2 ## per-capita growth rate
K <- 50
## initialize storage for population sizes
n <- vector(mode='numeric', length=length(0:tmax))
n[1] <- n0 ## store the initial population size
for (t in (t0+1):tmax) {
n[t+1] <- n[t] + r*n[t]*(1-n[t]/K)
}
plot(x=t0:tmax, y=n, type='l')
r <- 2.49 ## per-capita growth rate
K <- 50
## initialize storage for population sizes
n <- vector(mode='numeric', length=length(0:tmax))
n[1] <- n0 ## store the initial population size
for (t in (t0+1):tmax) {
n[t+1] <- n[t] + r*n[t]*(1-n[t]/K)
}
plot(x=t0:tmax, y=n, type='l')
r <- 2.5 ## per-capita growth rate
K <- 50
## initialize storage for population sizes
n <- vector(mode='numeric', length=length(0:tmax))
n[1] <- n0 ## store the initial population size
for (t in (t0+1):tmax) {
n[t+1] <- n[t] + r*n[t]*(1-n[t]/K)
}
plot(x=t0:tmax, y=n, type='l')
r <- 2.56 ## per-capita growth rate
K <- 50
## initialize storage for population sizes
n <- vector(mode='numeric', length=length(0:tmax))
n[1] <- n0 ## store the initial population size
for (t in (t0+1):tmax) {
n[t+1] <- n[t] + r*n[t]*(1-n[t]/K)
}
plot(x=t0:tmax, y=n, type='l')
r <- 2.565 ## per-capita growth rate
K <- 50
## initialize storage for population sizes
n <- vector(mode='numeric', length=length(0:tmax))
n[1] <- n0 ## store the initial population size
for (t in (t0+1):tmax) {
n[t+1] <- n[t] + r*n[t]*(1-n[t]/K)
}
plot(x=t0:tmax, y=n, type='l')
r <- 2.7 ## per-capita growth rate
K <- 50
## initialize storage for population sizes
n <- vector(mode='numeric', length=length(0:tmax))
n[1] <- n0 ## store the initial population size
for (t in (t0+1):tmax) {
n[t+1] <- n[t] + r*n[t]*(1-n[t]/K)
}
plot(x=t0:tmax, y=n, type='l')
r <- 3 ## per-capita growth rate
K <- 50
## initialize storage for population sizes
n <- vector(mode='numeric', length=length(0:tmax))
n[1] <- n0 ## store the initial population size
for (t in (t0+1):tmax) {
n[t+1] <- n[t] + r*n[t]*(1-n[t]/K)
}
plot(x=t0:tmax, y=n, type='l')
for (t in (t0+1):tmax) {
n[t+1] <- n[t] + r*n[t]*(1-n[t]/K)
}
plot(x=t0:tmax, y=n, type='l')
n0 <- 1.001 ## initial population size
r <- 3 ## per-capita growth rate
K <- 50
## initialize storage for population sizes
n <- vector(mode='numeric', length=length(0:tmax))
n[1] <- n0 ## store the initial population size
for (t in (t0+1):tmax) {
n[t+1] <- n[t] + r*n[t]*(1-n[t]/K)
}
plot(x=t0:tmax, y=n, type='l')
## specify the parameters
pars <- c(r=3, K=50)
## times to record
times <- seq(t0,tmax,1)
out <- ode(y=y, times=times, func=contLog, parms=pars, method="lsoda")
plot(x=out[,"time"], y=out[,"n"], type='l')
## Bifurcation diagram- how do dynamics change as you change a single parameter
tmax <- 500
n0 <- 1 ## initial population size
## set up storage
store <- array(NA, dim=c(50,length(seq(1,3,0.01))))
for (j in 1:length(seq(1,3,0.01))) {
r <- seq(1,3,0.01)[j]
n <- vector(mode='numeric', length=length(0:tmax))
n[1] <- n0 ## store the initial population size
for (t in (t0+1):tmax) {
n[t+1] <- n[t] + r*n[t]*(1-n[t]/K)
}
## store the final 50 timepoints in column j
store[,j] <- tail(n,50)
}
plot.new()
plot.window(xlim=c(1,3), ylim=range(store))
axis(1); axis(2); box('plot')
for (j in 1:ncol(store)) {
points(rep(seq(1,3,0.01)[j],50), store[,j], pch=21, bg=1, cex=0.1)
}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
pick_individuals <- function(N0, traitmean, traitsd) {
mu <- log(traitmean^2 / sqrt(traitsd^2+traitmean^2))
sigma <- sqrt(log(traitsd^2/traitmean^2 + 1))
## record this initial distribution in the output
return(rlnorm(N0, meanlog=mu, sdlog=sigma))
}
## generate many different individuals
set.seed(10010)
b <- pick_individuals(100, 0.25, 0.05)
## simulate the choosing of individuals and events under both GEM formulations many, many times and confirm that the probabilities of any individual being chosen match the expectation derived above
s <- 2
bs <- ds <- 5e-4
## generate many different individuals
set.seed(10010)
## generate many different individuals
set.seed(10010)
## generate many different individuals
set.seed(10010)
b <- pick_individuals(100, 0.25, 0.05)
## simulate the choosing of individuals and events under both GEM formulations many, many times and confirm that the probabilities of any individual being chosen match the expectation derived above
s <- 2
bs <- ds <- 5e-4
data.frame(ind=sample(1:length(b), 1e5, replace=TRUE), ## pick individuals at random
rand=runif(1e5), ## draw a random number
birth=rep(0,1e5),
death=rep(0,1e5)) %>%
mutate(birth=ifelse(rand > (b[ind]-bs*length(b))/(b[ind]-bs*length(b)+s*b[ind]^2+ds*length(b)), 0, 1), ## compare the random number to the relative rate of birth
death=ifelse(birth==0,1,0)) -> events
## Alternative GEM
events2 <- array(NA, dim=c(1e5,3))
## create the "wheel" of fortune cumsum'ing all of the individual per-capita rates
brates <- b-bs*length(b)
drates <- s*b^2+ds*length(b)
rates <- c(brates, drates)
wheel <- cumsum(rates)/sum(rates)
for (i in 1:1e5) {
## choose an individual and event at random
rand <- runif(1)
## who does the event happen to?
ind <- ifelse(min(which(rand < wheel)) <= length(b),
min(which(rand < wheel)),
min(which(rand < wheel))-length(b))
## which event happens?
birth <- death <- 0
if (rand <= sum(brates)/sum(rates))
birth <- 1
else death <- 1
events2[i,] <- c(ind,birth,death)
}
events2 <- as.data.frame(events2)
colnames(events2) <- c("ind","birth","death")
head(events)
## what is the average birth rate under the two simulations?
nbirths_orig <- sum(events$birth)
nbirths_orig
sum(events$birth)
sum(events2$birth)
library(tidyverse)
out1 <- readRDS("Logistic_GEM_bs=ds=025_varying_b0_and_N0.RDS")
out2 <- readRDS("Logistic_GEM_bs=ds=025_varying_b0_N0=10.RDS")
out3 <- readRDS("Logistic_GEM_bs=ds=025_varying_b0_N0=50.RDS")
setwd("~/gems/logistic")
out1 <- readRDS("Logistic_GEM_bs=ds=025_varying_b0_and_N0.RDS")
out2 <- readRDS("Logistic_GEM_bs=ds=025_varying_b0_N0=10.RDS")
out3 <- readRDS("Logistic_GEM_bs=ds=025_varying_b0_N0=50.RDS")
ggplot(out1, aes(x=time, y=N)) + facet_wrap(~init) + geom_line() + theme_bw()
ggplot(out1, aes(x=time, y=b)) + facet_wrap(~init) + geom_line() + theme_bw()
?gather
out1 %>% pivot_longer(c(N,b), names_to="Var", values_to="Val") -> o1
dim(out1)
dim(o1)
ggplot(o1, aes(x=time, y=Val)) + facet_wrap(init~Var) + geom_line() + theme_bw()
data(mtcars)
mtcars
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
mean_Val <- o1 %>% group_by(init, Var) %>% summarize(meanVal=mean(tail(Val,100)))
mean_Val
(3-1/6*3^2)
(3-1/6*3^2)/(0.05)
source("logistic_GEM.R")
## Start at the ecological equilibrium given the trait value
bmax_seq <- seq(0.5,5.5,0.5)
s <- 1/6
bs <- ds <- 0.025
N0_seq <- sapply(bmax_seq, function(b) (b-s*b^2)/(bs+ds))
output1 <- vector(mode='list', length=length(bmax_seq))
i = 3
set.seed(1343421)
seeds <- floor(runif(100, 1, 1e5))
mclapply(seeds,
function(s) logistic_GEM(seed=s, dt=1, tmax=100, N0=N0_seq[i], traitmean=bmax_seq[i], traitcv=0.3, h2=0.75, bs=bs, ds=ds, slope=s),
mc.cores=8
) -> out
library(parallel)
set.seed(1343421)
seeds <- floor(runif(100, 1, 1e5))
mclapply(seeds,
function(s) logistic_GEM(seed=s, dt=1, tmax=100, N0=N0_seq[i], traitmean=bmax_seq[i], traitcv=0.3, h2=0.75, bs=bs, ds=ds, slope=s),
mc.cores=8
) -> out
logistic_GEM(seed=s, dt=1, tmax=1000, N0=10, traitmean=bmax_seq[i], traitcv=0.3, h2=0.75, bs=bs, ds=ds, slope=s) -> out
out
l = out
l$traits
lapply(l$traits, mean)
lapply(l$traits, mean) %>% unlist
1-2*s*(lapply(l$traits, mean) %>% unlist)
lapply(seeds,
function(s) logistic_GEM(seed=s, dt=1, tmax=100, N0=10, traitmean=bmax_seq[i], traitcv=0.3, h2=0.75, bs=bs, ds=ds, slope=s)
) -> out
out
dim(out)
length(out)
out[[1]]
seeds
i
(1.5-1/6*1.5^2)/(0.05)
lapply(seeds,
function(s) logistic_GEM(seed=s, dt=1, tmax=100, N0=22, traitmean=1.5, traitcv=0.3, h2=0.75, bs=bs, ds=ds, slope=s),
) -> out
lapply(seeds,
function(s) logistic_GEM(seed=s, dt=1, tmax=100, N0=22, traitmean=1.5, traitcv=0.3, h2=0.75, bs=bs, ds=ds, slope=s),
) -> out
lapply(seeds,
function(s) logistic_GEM(seed=s, dt=1, tmax=100, N0=22, traitmean=1.5, traitcv=0.3, h2=0.75, bs=bs, ds=ds, slope=s)
) -> out
out[[1]][[2]][[1]]
out[[1]][[2]][[2]]
out[[3]][[2]][[2]]
out[[4]][[2]][[2]]
logistic_GEM(seed=s, dt=1, tmax=100, N0=22, traitmean=1.5, traitcv=0.3, h2=0.75, bs=bs, ds=ds, slope=s) -> o
o
out <- vector(mode='list', length=100)
for (j in 1:100)
out[[j]] <- logistic_GEM(seed=seeds[j], dt=1, tmax=100, N0=22, traitmean=1.5, traitcv=0.3, h2=0.75, bs=bs, ds=ds, slope=s)
lapply(out, function(l) 1-2*s*(lapply(l$traits, mean) %>% unlist)) %>% do.call("cbind.data.frame",.)
lapply(out, function(l) 1-2*s*(lapply(l$traits, mean) %>% unlist)) %>% do.call("cbind.data.frame",.) %>% apply(.,1,mean)
lapply(out, function(l) 1-2*s*(lapply(l$traits, mean) %>% unlist)) %>% do.call("cbind.data.frame",.) %>% apply(.,1,function(r) mean(r,na.rm=TRUE))
lapply(out, function(l) 1-2*s*(lapply(l$traits, mean) %>% unlist)) %>% do.call("cbind.data.frame",.) %>% apply(.,1,function(r) mean(r,na.rm=TRUE)) %>% plot.ts(.)
