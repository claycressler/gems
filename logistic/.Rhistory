mtext(side=1, "Time", line=3)
mtext(side=2, "Mean(bmax)", line=2.5)
for (i in 1:length(out3)) lines(time.seq, btraj[,i], col=gray(0.7))
lines(time.seq, apply(btraj, 1, mean), lwd=2)
abline(h=2.43961, lty=2, col=2)
set.seed(123210)
seeds <- floor(runif(40,1,1e6))
library(parallel)
mclapply(seeds,
function(s) logistic_GEM_cull(s, dt=0.1, tmax, N0, traitmean, traitcv, h2, bs, ds, slope,X=1000,Ncull=40),
mc.cores=8
) -> out3
Ntraj <- lapply(out3, function(o) lapply(o[[2]],length) %>% unlist) %>% unlist %>% matrix(., ncol=length(out3), byrow=F)
btraj <- lapply(out3, function(o) lapply(o[[2]],mean) %>% unlist) %>% unlist %>% matrix(., ncol=length(out3), byrow=F)
lapply(o[[2]],length) %>% unlist)
lapply(out3, function(o) lapply(o[[2]],length) %>% unlist)
lapply(out3, function(o) lapply(o[[2]],length) %>% unlist) %>% lapply(., length)
lapply(out3, function(o) lapply(o[[2]],length) %>% unlist) %>% lapply(., length) %>% unlist
(lapply(out3, function(o) lapply(o[[2]],length) %>% unlist) %>% lapply(., length) %>% unlist)
which((lapply(out3, function(o) lapply(o[[2]],length) %>% unlist) %>% lapply(., length) %>% unlist)==1002)
o = out3[[25]]
o
lapply(o[[2]],length)
lapply(o[[2]],length) %>% unlist
(lapply(o[[2]],length) %>% unlist)
(lapply(o[[2]],length) %>% unlist)[1:1001]
Ntraj <- (lapply(out3, function(o) lapply(o[[2]],length) %>% unlist))[1:1001] %>% unlist %>% matrix(., ncol=length(out3), byrow=F)
Ntraj <- lapply(out3, function(o) (lapply(o[[2]],length) %>% unlist)[1:1001]) %>% unlist %>% matrix(., ncol=length(out3), byrow=F)
Ntraj <- lapply(out3, function(o) (lapply(o[[2]],length) %>% unlist)[1:1001]) %>% unlist %>% matrix(., ncol=length(out3), byrow=F)
btraj <- lapply(out3, function(o) (lapply(o[[2]],mean) %>% unlist)[1:1001]) %>% unlist %>% matrix(., ncol=length(out3), byrow=F)
time.seq <- seq(0, tmax, 0.1)
## plot the mean trajectories across simulations:
par(mfrow=c(2,1), mar=c(4,4,0.5,0.5), oma=rep(0.5,4))
plot.new()
plot.window(xlim=c(0,tmax), ylim=c(0,150))
axis(1);axis(2);box('plot')
mtext(side=1, "Time", line=3)
mtext(side=2, "Population size", line=2.5)
for (i in 1:length(out3)) lines(time.seq, Ntraj[,i], col=gray(0.7))
lines(time.seq, apply(Ntraj, 1, mean), lwd=2)
plot.new()
plot.window(xlim=c(0,tmax), ylim=c(1,6))
axis(1);axis(2);box('plot')
mtext(side=1, "Time", line=3)
mtext(side=2, "Mean(bmax)", line=2.5)
for (i in 1:length(out3)) lines(time.seq, btraj[,i], col=gray(0.7))
lines(time.seq, apply(btraj, 1, mean), lwd=2)
abline(h=2.43961, lty=2, col=2)
## Read in all of the data on Covid-19 at the state level
x <- read.csv(url("https://covidtracking.com/api/v1/states/daily.csv"))
## Read in the population sizes of every state to make appropriate per 100k calculations
y <- read.csv(url("https://www2.census.gov/programs-surveys/popest/datasets/2010-2019/state/detail/SCPRC-EST2019-18+POP-RES.csv"))
## add abbreviations to census data
y$state <- c("USA","AL","AK","AZ","AR","CA","CO","CT","DE","DC","FL","GA","HI","ID","IL","IN","IA","KS","KY","LA","ME","MD","MA","MI","MN","MS","MO","MT","NE","NV","NH","NJ",'NM','NY','NC','ND','OH','OK','OR','PA','RI','SC','SD','TN','TX','UT','VT','VA','WA','WV','WI','WY','PR')
## merge the two datasets into a single dataset
merge(x,y,by='state') -> z
head(z)
mutate(z,
date=date %>% as.character %>% as.Date(., format="%Y%m%d"),
totTests=positive+negative,
infectedCurrently=ifelse(!is.na(recovered),positive-recovered,positive),
fracHospitalized=hospitalizedCurrently/infectedCurrently,
totCaseFatality=death/positive*100,
hospCaseFatality=death/hospitalized*100,
casesPer100k=positive/POPESTIMATE2019*100000,
testsPer100k=totTests/POPESTIMATE2019*100000,
deathsPer100k=death/POPESTIMATE2019*100000,
newCasesPer100k=positiveIncrease/POPESTIMATE2019*100000,
testPosRate=positive/totTests) -> z
## Drop some territories where I don't have population data
z[!(z$state %in% (sapply(levels(z$state), function(s) with(subset(z, state==s),all(is.na(casesPer100k)))) %>% which %>% names)),] -> z
z$state <- factor(z$state)
levels(z$state)
specifyState <- c("NE")
stateColors <- data.frame(state=levels(z$state),
stateColor=1)
stateColors$stateColor[stateColors$state%in%specifyState] <- 2.5
## these two lines make the chosen states the last to be plotted
for (i in specifyState) z$state <- relevel(z$state, i)
z$state <- factor(z$state, levels=rev(levels(z$state)))
par(mar=c(3,5,0.5,0.5), oma=rep(0,4))
plot.new()
plot.window(xlim=c(18325, max(z$date,na.rm=T)+0.5), ylim=range(z$casesPer100k, na.rm=T))
axis(2); axis(1, at=seq(18325,18388,by=7), labels=c("03/04/20","03/11/20","03/18/20","03/25/20","04/01/20","04/08/20","04/15/20","04/22/20","04/29/20","05/06/20")); box('plot')
mtext(side=2, line=3, "Cases per 100k population")
sapply(levels(z$state), function(s) with(subset(z, state==s), lines(date[order(date)], casesPer100k[order(date)], col=gray((2.5-stateColors$stateColor[which(stateColors$state==s)])/2), lwd=stateColors$stateColor[which(stateColors$state==s)])))
sapply(levels(z$state), function(s) with(subset(z, state==s), text(max(date)+0.5, max(casesPer100k,na.rm=T), s, col=gray((2.5-stateColors$stateColor[which(stateColors$state==s)])/2))))
dev.off()
par(mar=c(3,5,0.5,0.5), oma=rep(0,4))
plot.new()
plot.window(xlim=c(18325, max(z$date,na.rm=T)+0.5), ylim=range(z$casesPer100k, na.rm=T))
axis(2); axis(1, at=seq(18325,18388,by=7), labels=c("03/04/20","03/11/20","03/18/20","03/25/20","04/01/20","04/08/20","04/15/20","04/22/20","04/29/20","05/06/20")); box('plot')
mtext(side=2, line=3, "Cases per 100k population")
sapply(levels(z$state), function(s) with(subset(z, state==s), lines(date[order(date)], casesPer100k[order(date)], col=gray((2.5-stateColors$stateColor[which(stateColors$state==s)])/2), lwd=stateColors$stateColor[which(stateColors$state==s)])))
sapply(levels(z$state), function(s) with(subset(z, state==s), text(max(date)+0.5, max(casesPer100k,na.rm=T), s, col=gray((2.5-stateColors$stateColor[which(stateColors$state==s)])/2))))
par(mar=c(3,5,0.5,0.5), oma=rep(0,4))
plot.new()
plot.window(xlim=c(18325, max(z$date,na.rm=T)+0.5), ylim=range(z$testsPer100k, na.rm=T))
axis(2); axis(1, at=seq(18325,18388,by=7), labels=c("03/04/20","03/11/20","03/18/20","03/25/20","04/01/20","04/08/20","04/15/20","04/22/20","04/29/20","05/06/20")); box('plot')
mtext(side=2, line=3, "Tests per 100k population")
sapply(levels(z$state), function(s) with(subset(z, state==s), lines(date[order(date)], testsPer100k[order(date)], col=gray((2.5-stateColors$stateColor[which(stateColors$state==s)])/2), lwd=stateColors$stateColor[which(stateColors$state==s)])))
sapply(levels(z$state), function(s) with(subset(z, state==s), text(max(date)+0.5, max(testsPer100k,na.rm=T), s, col=gray((2.5-stateColors$stateColor[which(stateColors$state==s)])/2))))
par(mar=c(3,5,0.5,0.5), oma=rep(0,4))
plot.new()
plot.window(xlim=c(18325, max(z$date,na.rm=T)+0.5), ylim=range(z$casesPer100k, na.rm=T))
axis(2); axis(1, at=seq(18325,18388,by=7), labels=c("03/04/20","03/11/20","03/18/20","03/25/20","04/01/20","04/08/20","04/15/20","04/22/20","04/29/20","05/06/20")); box('plot')
mtext(side=2, line=3, "Cases per 100k population")
sapply(levels(z$state), function(s) with(subset(z, state==s), lines(date[order(date)], casesPer100k[order(date)], col=gray((2.5-stateColors$stateColor[which(stateColors$state==s)])/2), lwd=stateColors$stateColor[which(stateColors$state==s)])))
sapply(levels(z$state), function(s) with(subset(z, state==s), text(max(date)+0.5, max(casesPer100k,na.rm=T), s, col=gray((2.5-stateColors$stateColor[which(stateColors$state==s)])/2))))
par(mar=c(3,5,0.5,0.5), oma=rep(0,4))
plot.new()
plot.window(xlim=c(18325, max(z$date,na.rm=T)+0.5), ylim=c(0,0.45))
axis(2); axis(1, at=seq(18325,18388,by=7), labels=c("03/04/20","03/11/20","03/18/20","03/25/20","04/01/20","04/08/20","04/15/20","04/22/20","04/29/20","05/06/20")); box('plot')
mtext(side=2, line=3, "Case positivity rate")
sapply(levels(z$state), function(s) with(subset(z, state==s), lines(date[order(date)], testPosRate[order(date)], col=gray((2.5-stateColors$stateColor[which(stateColors$state==s)])/2), lwd=stateColors$stateColor[which(stateColors$state==s)])))
sapply(levels(z$state), function(s) with(subset(z, state==s), text(max(date)+0.5, tail(testPosRate[order(date)],1), s, col=gray((2.5-stateColors$stateColor[which(stateColors$state==s)])/2))))
par(mar=c(3,5,0.5,0.5), oma=rep(0,4))
plot.new()
plot.window(xlim=c(18325, max(z$date,na.rm=T)+0.5), ylim=range(z$deathsPer100k,na.rm=T))
axis(2); axis(1, at=seq(18325,18388,by=7), labels=c("03/04/20","03/11/20","03/18/20","03/25/20","04/01/20","04/08/20","04/15/20","04/22/20","04/29/20","05/06/20")); box('plot')
mtext(side=2, line=3, "Deaths per 100k population")
sapply(levels(z$state), function(s) with(subset(z, state==s), lines(date[order(date)], deathsPer100k[order(date)], col=gray((2.5-stateColors$stateColor[which(stateColors$state==s)])/2), lwd=stateColors$stateColor[which(stateColors$state==s)])))
sapply(levels(z$state), function(s) with(subset(z, state==s), text(max(date)+0.5, tail(deathsPer100k[order(date)],1), s, col=gray((2.5-stateColors$stateColor[which(stateColors$state==s)])/2))))
par(mar=c(3,5,0.5,0.5), oma=rep(0,4))
plot.new()
plot.window(xlim=c(18325, max(z$date,na.rm=T)+0.5), ylim=range(z$newCasesPer100k,na.rm=T))
axis(2); axis(1, at=seq(18325,18388,by=7), labels=c("03/04/20","03/11/20","03/18/20","03/25/20","04/01/20","04/08/20","04/15/20","04/22/20","04/29/20","05/06/20")); box('plot')
mtext(side=2, line=3, "Daily new cases per 100k population")
sapply(levels(z$state), function(s) with(subset(z, state==s), lines(date[order(date)], newCasesPer100k[order(date)], col=gray((2.5-stateColors$stateColor[which(stateColors$state==s)])/2), lwd=stateColors$stateColor[which(stateColors$state==s)])))
sapply(levels(z$state), function(s) with(subset(z, state==s), text(max(date)+0.5, tail(newCasesPer100k[order(date)],1), s, col=gray((2.5-stateColors$stateColor[which(stateColors$state==s)])/2))))
par(mar=c(4,4,0.5,0.5), oma=rep(0,4))
plot.new()
plot.window(xlim=range(z$testsPer100k,na.rm=T), ylim=range(z$casesPer100k))
axis(1); axis(2); box('plot')
mtext(side=1, line=3, "Tests per 100k population")
mtext(side=2, line=3, "Cases per 100k population")
sapply(levels(z$state), function(s) with(subset(z, state==s), lines(testsPer100k[order(date)], casesPer100k[order(date)], col=gray((2.5-stateColors$stateColor[which(stateColors$state==s)])/2), lwd=stateColors$stateColor[which(stateColors$state==s)])))
sapply(levels(z$state), function(s) with(subset(z, state==s), text(max(testsPer100k,na.rm=T), max(casesPer100k,na.rm=T), s, col=gray((2.5-stateColors$stateColor[which(stateColors$state==s)])/2))))
library(patchwork)
z %>% group_by(date) %>% summarise(totCases=sum(positive,na.rm=T), totNewCases=sum(positiveIncrease,na.rm=T), totTests=sum(totalTestResults,na.rm=T), totNewTests=sum(totalTestResultsIncrease,na.rm=T), totDeaths=sum(death,na.rm=T), totNewDeaths=sum(deathIncrease,na.rm=T), casePosRate=sum(positive,na.rm=T)/sum(totalTestResults,na.rm=T)) %>% subset(., date > "2020-03-01")-> nationalSummary
p1 <- ggplot(nationalSummary, aes(x=date, y=totCases)) + geom_line() + theme_bw()
p2 <- ggplot(nationalSummary, aes(x=date, y=totTests)) + geom_line() + theme_bw()
p3 <- ggplot(nationalSummary, aes(x=date, y=totDeaths)) + geom_line() + theme_bw()
p4 <- ggplot(nationalSummary, aes(x=date, y=totNewCases)) + geom_line() + theme_bw()
p5 <- ggplot(nationalSummary, aes(x=date, y=totNewTests)) + geom_line() + theme_bw()
p6 <- ggplot(nationalSummary, aes(x=date, y=totNewDeaths)) + geom_line() + theme_bw()
p7 <- ggplot(nationalSummary, aes(x=date, y=casePosRate)) + geom_line() + coord_cartesian(ylim=c(0.1,0.25)) + theme_bw()
(p4+p6)/(p5+p7)
Mu=c(0.5, 1.2)
Sigma=c(0.05,0.12)
R = matrix(c(1,0.5,0.5,1), ncol=2, byrow=T)
R
p <- length(Mu)
Alpha = matrix(0,p,1)
Alpha
Beta = matrix(0,p,p)
Beta
for (i in 1:p) {}
for (i in 1:p) {Alpha[i] = log(Mu[i]) - (1/2)*log(1+Sigma[i]/Mu[i]^2); Beta[i,i] = log(1+Sigma[i]/(Mu[i]^2))}
Alpha[i]
Alpha
Beta
Delta = sqrt(Beta)%*%R%*%sqrt(Beta)
Delta
Delta.Eigen=eigen(Delta)
Delta.EigenVal <- Delta.Eigen$values*(abs(Delta.Eigen$values) >= 1e-12);
Delta.Eigen
Delta.EigenVal
RootDelta = (Delta.Eigen$vectors)%*%diag(sqrt(Delta.EigenVal))%*%t(Delta.Eigen$vectors)
RootDelta
X <- matrix(rnorm(p*n,0,1), nrow = n, ncol = p)
n = 1
X <- matrix(rnorm(p*n,0,1), nrow = n, ncol = p)
X
for (i in 1:n){
X[i,] <- exp(Alpha + RootDelta%*%X[i,]);
}
X
mvlognormal <-
function(n = 1,Mu,Sigma, R){
## Generate Lognormal random variables with zeros.
## Mu - Mean of the actual lognormal variables
## Sigma - Diagonal of the covariance matrix of the actual variables.
## R - Correlation matrix for the log-transformed normal variables. This is to ensure the normal distribution corresponding to the lognormals exists
if (dim(R)[1] != dim(R)[2]){
stop("Correlation matrix is not square.");
}
p <- length(Mu);
if (length(Sigma) != p){
stop("Mean and covariance matrix are not of same dimension")
}
Alpha <- matrix(0,p,1);
Beta <- matrix(0,p,p);
## Alpha and Beta are the converted mean and covariance-diagonal matrix of the log-transformed normal variable.
for (i in 1:p){
if (abs(Mu[i]) >= .Machine$double.eps){
Alpha[i] = log(Mu[i]) - (1/2)*log(1 + Sigma[i]/Mu[i]^2);
Beta[i,i] = log(1 + Sigma[i]/(Mu[i]^2));
}
if (abs(Mu[i]) < .Machine$double.eps){
Alpha[i] = -Inf;
Beta[i,i] = 0;
}
}
Delta = sqrt(Beta)%*%R%*%sqrt(Beta);
Delta.Eigen = eigen(Delta);
Delta.EigenVal <- Delta.Eigen$values*(abs(Delta.Eigen$values) >= 1e-12);
RootDelta = (Delta.Eigen$vectors)%*%diag(sqrt(Delta.EigenVal))%*%t(Delta.Eigen$vectors);
X <- matrix(rnorm(p*n,0,1), nrow = n, ncol = p);
for (i in 1:n){
X[i,] <- exp(Alpha + RootDelta%*%X[i,]);
}
return(X);
}
mvlognormal(10, Mu, Sigma, R)
Alpha
rlnorm(10, Alpha[1,1], Beta[1,1])
Beta
Mu
Sigma
location = log(Mu[1]^2/sqrt(Mu[1]^2+Sigma[1]^2))
location
log(1+Sigma[1]/(Mu[1]^2))
Delta
Alpha
location
Alpha[1]
log(Mu[1])-(1/2)*log(1+Sigma[1]/Mu[1]^2)
log(Mu[1]^2/sqrt(Mu[1]^2+Sigma[1]^2)
)
log(Mu[1])+(1/2)*log(1+Sigma[1]/Mu[1]^2)
log(Mu[1])-(1/2)*log(1+Sigma[1]/Mu[1]^2)
for (i in 1:p){
if (abs(Mu[i]) >= .Machine$double.eps){
Alpha[i] = log(Mu[i]) - (1/2)*log(1 + Sigma[i]^2/Mu[i]^2);
Beta[i,i] = log(1 + Sigma[i]/(Mu[i]^2));
}
}
Alpha
location
shape
shape = sqrt(1+(Sigma[1]^2/Mu[1]^2))
shape
shape = sqrt(log(1+(Sigma[1]^2/Mu[1]^2)))
shape
or (i in 1:p){
if (abs(Mu[i]) >= .Machine$double.eps){
Alpha[i] = log(Mu[i]) - (1/2)*log(1 + Sigma[i]^2/Mu[i]^2);
Beta[i,i] = log(1 + Sigma[i]^2/(Mu[i]^2));
}
if (abs(Mu[i]) < .Machine$double.eps){
Alpha[i] = -Inf;
Beta[i,i] = 0;
}
}
for (i in 1:p){
if (abs(Mu[i]) >= .Machine$double.eps){
Alpha[i] = log(Mu[i]) - (1/2)*log(1 + Sigma[i]^2/Mu[i]^2);
Beta[i,i] = log(1 + Sigma[i]^2/(Mu[i]^2));
}
if (abs(Mu[i]) < .Machine$double.eps){
Alpha[i] = -Inf;
Beta[i,i] = 0;
}
}
Alpha
Beta
for (i in 1:p){
if (abs(Mu[i]) >= .Machine$double.eps){
Alpha[i] = log(Mu[i]) - (1/2)*log(1 + Sigma[i]/Mu[i]^2);
Beta[i,i] = log(1 + Sigma[i]/(Mu[i]^2));
}
if (abs(Mu[i]) < .Machine$double.eps){
Alpha[i] = -Inf;
Beta[i,i] = 0;
}
}
Alpha
Beta
location = log(Mu[1]^2/sqrt(Sigma[1]+Mu[1]^2))
location
shape = sqrt(log(1+Sigma[1]/Mu[1]^2))
shape
sqrt(Beta)
rlnorm(10, location, shape)
mvlognormal(10, Mu, Sigma, R)
R
R = matrix(c(1,0,0,1), ncol=2, byrow=T)
R
mvlognormal(10, Mu, Sigma, R)
x = mvlognormal(1000000, Mu, Sigma, R)[,1]
y = rlnorm(1000000, location, shape)
mean(x)
mean(y)
var(x)
var(y)
Delta.Eigen$values
RootDelta
Delta
sum(RootDelta)
(abs(Delta.Eigen$values) >= 1e-12)
Delta.Eigen$values
Delta.Eigen$vectors%*%diag(Delta.EigenVal)%*%t(Delta.Eigen$vectors)
Delta
chol(Delta)
RootDelta
mvlognormal <-function(n = 1,Mu,Sigma, R){
## Generate Lognormal random variables with zeros.
## Mu - Mean of the actual lognormal variables
## Sigma - Diagonal of the covariance matrix of the actual variables.
## R - Correlation matrix for the log-transformed normal variables. This is to ensure the normal distribution corresponding to the lognormals exists
if (dim(R)[1] != dim(R)[2]){
stop("Correlation matrix is not square.");
}
p <- length(Mu);
if (length(Sigma) != p){
stop("Mean and covariance matrix are not of same dimension")
}
Alpha <- matrix(0,p,1);
Beta <- matrix(0,p,p);
## Alpha and Beta are the converted mean and covariance-diagonal matrix of the log-transformed normal variable.
for (i in 1:p){
if (abs(Mu[i]) >= .Machine$double.eps){
Alpha[i] = log(Mu[i]) - (1/2)*log(1 + Sigma[i]/Mu[i]^2);
Beta[i,i] = log(1 + Sigma[i]/(Mu[i]^2));
}
}
## Use correlation matrix R to create the covariance matrix Delta
Delta <- sqrt(Beta)%*%R%*%sqrt(Beta);
## Calculate the eigenvalues and eigenvectors of the covariance matrix
Delta.Eigen <- eigen(Delta);
## Set any eigenvalue < 1e-12 equal to 0
Delta.EigenVal <- Delta.Eigen$values*(abs(Delta.Eigen$values) >= 1e-12);
## Use the eigenvalue decomposition to generate a new matrix, RootDelta
## that will be used to generate new random variables
## Follows the protocol laid out for drawing multivariate normal random variables in
## https://en.wikipedia.org/wiki/Multivariate_normal_distribution#Drawing_values_from_the_distribution
## and the source code for mvnorm.R
RootDelta = (Delta.Eigen$vectors)%*%diag(sqrt(Delta.EigenVal))%*%t(Delta.Eigen$vectors);
## Draw normal random variables with mean 0 and sd 1
X <- matrix(rnorm(p*n,0,1), nrow = n, ncol = p);
## Convert to lognormal random variables with the appropriate covariance structure
for (i in 1:n){
#X[i,] <- exp(Alpha + RootDelta%*%X[i,]);
X[i,] <- exp(Alpha + chol(Delta)%*%X[i,])
}
return(X);
}
x2 = mvlognormal(1000000, Mu, Sigma, R)[,1]
mean(x2)
var(x2)
mean(x)
var(x)
system.time(chol(Delta))
pick_individuals_multivariate <-function(N, traitmeans, traitsds, corr){
## Generate Lognormal random variables with zeros.
## traitmeans - Vector of mean trait values
## traitsds - Vector of trait standard deviations
## R - Correlation matrix - should have 1s along the diagonal and off-diagonal elements reflecting correlations between different variables
## Number of traits
p <- length(traitmeans);
## mu and sigma are the converted mean and covariance matrix of the log-transformed normal variable.
mu <- matrix(0,p,1);
sigma <- matrix(0,p,p);
for (i in 1:p) {
mu[i] = log(traitmeans[i]^2 / sqrt(traitsds[i]^2+traitmeans[i]^2))
sigma[i,i] = log(1 + traitsds[i]^2/traitmeans[i]^2);
}
## Use correlation matrix R to create the covariance matrix Cov
Cov <- sqrt(sigma)%*%R%*%sqrt(sigma);
## Following the protocol laid out for drawing multivariate normal random variables in
## https://en.wikipedia.org/wiki/Multivariate_normal_distribution#Drawing_values_from_the_distribution
## Draw normal random variables with mean 0 and sd 1
X <- matrix(rnorm(p*n,0,1), nrow = n, ncol = p);
## Convert to lognormal random variables with the appropriate covariance structure
## using Cholesky decomposition of the covariance matrix
for (i in 1:n){
X[i,] <- exp(mu + chol(Cov)%*%X[i,])
}
return(X);
}
pick_individuals <- function(N0, traitmean, traitsd) {
mu <- log(traitmean^2 / sqrt(traitsd^2+traitmean^2))
sigma <- sqrt(log(traitsd^2/traitmean^2 + 1))
## record this initial distribution in the output
return(rlnorm(N0, meanlog=mu, sdlog=sigma))
}
## Comparing the two methods
traitmeans <- c(1.5,0.8)
traitsds <- c(0.15, 0.08)
## if correlations are equal to 0, then pick_individuals and pick_individuals_multivariate should look very similar
corr <- matrix(c(1,0,0,1), nrow=2, byrow=T)
## Comparing the two methods
traitmeans <- c(1.5,0.8)
traitsds <- c(0.15, 0.08)
## if correlations are equal to 0, then pick_individuals and pick_individuals_multivariate should look very similar
corr <- matrix(c(1,0,0,1), nrow=2, byrow=T)
trait1 <- pick_individuals(1e5, traitmean=traitmeans[1], traitsd=traitsds[1])
trait2 <- pick_individuals(1e5, traitmean=traitmeans[2], traitsd=traitsds[2])
traits <- pick_individuals_multivariate(1e5, traitmeans, traitsds, corr)
## Compare
mean(trait1)
var(trait1)
mean(traits[,1])
var(traits[,1])
traits[,1]
pick_individuals_multivariate <-function(N, traitmeans, traitsds, corr){
## Generate Lognormal random variables with zeros.
## traitmeans - Vector of mean trait values
## traitsds - Vector of trait standard deviations
## R - Correlation matrix - should have 1s along the diagonal and off-diagonal elements reflecting correlations between different variables
## Number of traits
p <- length(traitmeans);
## mu and sigma are the converted mean and covariance matrix of the log-transformed normal variable.
mu <- matrix(0,p,1);
sigma <- matrix(0,p,p);
for (i in 1:p) {
mu[i] = log(traitmeans[i]^2 / sqrt(traitsds[i]^2+traitmeans[i]^2))
sigma[i,i] = log(1 + traitsds[i]^2/traitmeans[i]^2);
}
## Use correlation matrix R to create the covariance matrix Cov
Cov <- sqrt(sigma)%*%corr%*%sqrt(sigma);
## Following the protocol laid out for drawing multivariate normal random variables in
## https://en.wikipedia.org/wiki/Multivariate_normal_distribution#Drawing_values_from_the_distribution
## Draw normal random variables with mean 0 and sd 1
X <- matrix(rnorm(p*n,0,1), nrow = n, ncol = p);
## Convert to lognormal random variables with the appropriate covariance structure
## using Cholesky decomposition of the covariance matrix
for (i in 1:N){
X[i,] <- exp(mu + chol(Cov)%*%X[i,])
}
return(X);
}
traits <- pick_individuals_multivariate(1e5, traitmeans, traitsds, corr)
pick_individuals_multivariate <-function(N, traitmeans, traitsds, corr){
## Generate Lognormal random variables with zeros.
## traitmeans - Vector of mean trait values
## traitsds - Vector of trait standard deviations
## R - Correlation matrix - should have 1s along the diagonal and off-diagonal elements reflecting correlations between different variables
## Number of traits
p <- length(traitmeans);
## mu and sigma are the converted mean and covariance matrix of the log-transformed normal variable.
mu <- matrix(0,p,1);
sigma <- matrix(0,p,p);
for (i in 1:p) {
mu[i] = log(traitmeans[i]^2 / sqrt(traitsds[i]^2+traitmeans[i]^2))
sigma[i,i] = log(1 + traitsds[i]^2/traitmeans[i]^2);
}
## Use correlation matrix R to create the covariance matrix Cov
Cov <- sqrt(sigma)%*%corr%*%sqrt(sigma);
## Following the protocol laid out for drawing multivariate normal random variables in
## https://en.wikipedia.org/wiki/Multivariate_normal_distribution#Drawing_values_from_the_distribution
## Draw normal random variables with mean 0 and sd 1
X <- matrix(rnorm(p*N,0,1), nrow = N, ncol = p);
## Convert to lognormal random variables with the appropriate covariance structure
## using Cholesky decomposition of the covariance matrix
for (i in 1:N){
X[i,] <- exp(mu + chol(Cov)%*%X[i,])
}
return(X);
}
pick_individuals <- function(N0, traitmean, traitsd) {
mu <- log(traitmean^2 / sqrt(traitsd^2+traitmean^2))
sigma <- sqrt(log(traitsd^2/traitmean^2 + 1))
## record this initial distribution in the output
return(rlnorm(N0, meanlog=mu, sdlog=sigma))
}
## Comparing the two methods
traitmeans <- c(1.5,0.8)
traitsds <- c(0.15, 0.08)
## if correlations are equal to 0, then pick_individuals and pick_individuals_multivariate should look very similar
corr <- matrix(c(1,0,0,1), nrow=2, byrow=T)
trait1 <- pick_individuals(1e5, traitmean=traitmeans[1], traitsd=traitsds[1])
trait2 <- pick_individuals(1e5, traitmean=traitmeans[2], traitsd=traitsds[2])
traits <- pick_individuals_multivariate(1e5, traitmeans, traitsds, corr)
## Compare
mean(trait1)
var(trait1)
mean(traits[,1])
var(traits[,1])
mean(trait2)
var(trait2)
mean(traits[,2])
var(traits[,2])
## Compare
mean(trait1)
sd(trait1)
mean(traits[,1])
sd(traits[,1])
mean(trait2)
sd(trait2)
mean(traits[,2])
sd(traits[,2])
## if correlations are non-zero (positive), how does that affect things?
corr <- matrix(c(1,0.5,0.5,1), nrow=2, byrow=T)
traits <- pick_individuals_multivariate(1e5, traitmeans, traitsds, corr)
corr <- matrix(c(1,0,0,1), nrow=2, byrow=T)
trait1 <- pick_individuals(1e5, traitmean=traitmeans[1], traitsd=traitsds[1])
trait2 <- pick_individuals(1e5, traitmean=traitmeans[2], traitsd=traitsds[2])
traits <- pick_individuals_multivariate(1e5, traitmeans, traitsds, corr)
## if correlations are non-zero (positive), how does that affect things?
corr <- matrix(c(1,0.5,0.5,1), nrow=2, byrow=T)
traits_pos <- pick_individuals_multivariate(1e5, traitmeans, traitsds, corr)
traits_pos
mean(traits_pos[,1])
mean(traits_pos[,2])
apply(traits_pos, 2, mean)
apply(traits_pos, 2, sd)
plot(traits_pos)
points(traits)
plot(traits_pos)
points(traits, col=2)
