---
title: "GEMs with true genotypes"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

I want to consider putting actual genotypes into a GEM. 
How would that work?
The easiest way, I think, is to allow users to specify the additive genetic variance in the evolving trait and an initial number of individuals.
For simplicity, and to make the new version most parallel with the old version, each individual will be assumed to have a unique genotype.
Thus, each genotype is characterized by what I will call an "expected phenotype."
The user can also specify a heritability that determines how "faithfully" a genotype passes on its expected phenotype.
When heritability is 1, offspring inherit the phenotype of their parent, which is by definition equal to the expected phenotype of the parent's genotype.
If, however, heritability is less than one, then offspring have a phenotype that is different from the expected phenotype, given their genotype.
That is, each individual is actually characterized by two traits: the phenotype they have (which determines their ecological interactions), and the phenotype they were expected to have, given their genotype.
What each individual passes on when they reproduce is not their *actual* phenotype, but their *expected* phenotype.
How do we use the user-specified heritability and initial additive genetic variance to generate new individuals?
We rely on the definition of heritability as the proportion of total phenotypic variance that is due to additive genetic variance: $H^2 = V_g/(V_g+V_e)$, where $V_g$ is the additive genetic variance and $V_e$ is the phenotypic variance due to the "environment."
Thus, given a heritability and initial additive genetic variance, we can calculate the phenotypic variance that is not heritable.
Then when an individual gives birth, the phenotype of its offspring is determined by drawing from a distribution with a mean equal to the genotypic mean, and variance given by $V_e$.
For evolution to occur in this new version of GEM, we have to a way to generate novel genetic variation.
We do this by the inclusion of a mutation rate: when an individual reproduces, with some small probability, its expected (genotypic) phenotype can change.
It's new expected phenotype is given by drawing from a distribution with mean equal to the current expected genotypic mean, and variance given by the mutational variance.
So the new model is entirely specified by a new "pick_individuals" function.
The function will be slightly flexible to accomodate whether the user is generating new *genotypes* (in which case, the user must specify an additive genetic variance $V_g$) or new *individuals* (in which case, the user must specify an environmental variance $V_e$, a probability of mutation $\mu$, and a mutational variance $V_\mu$). 
In R, this can be achieved by the following:
```{r}
## expected.trait is the expected phenotype of the individuals to generate
## 
## Ni is the total number of individuals to generate with expected.trait. Ni can be a single number or it can be a vector of length Ng.
## In the latter case, the function will generate Ni[j] individuals of each genotype j. In the former case, if Ng!=NULL then the Ni
## individuals will be spread evenly across the Ng genotypes.
## 
## Ve is the phenotypic variance that cannot be attributed to genotype
##
## Ng is the number of genotypes to generate. If Ng!=NULL, Vg must also be specified. 
##
## Vg is the additive genetic variance. If Vg!=NULL, Ng must also be specified.
## 
## m is the probability of mutation. If m!=NULL, Vm must also be specified.
##
## Vm is the variance in phenotypes generated by mutation. 
## 
## If both or neither Vg and Ve are specified, the function returns with a warning
##
## If Ve!=NULL and mu=Vmu=NULL, then mutation cannot occur and the only evolution that can happen is through the fluctuating of initial genotypes
##
## The function returns an array with Ni rows and two columns:
## (1) the first column gives the expected phenotype of the individual (i.e., its genotype); 
## (2) the second column gives the actual phenotype of the individual
## 
pick_individuals <- function(expected.trait, Ni, Ve, Ng=NULL, Vg=NULL, m=NULL, Vm=NULL) {
  if (is.null(Vg) & is.null(Ve)) stop("You must specify either Vg or Ve")
  else if (!is.null(Vg) & is.null(Ng)) stop("You must specify a number of genotypes to generate")
  else if (!is.null(Ng) & is.null(Vg)) stop("You must specify an additive genetic variance to generate genotypes")
  
  if (!is.null(m) & is.null(Vm)) stop ("You must specify a mutational variance")
  
  if (!is.null(Vg)) { ## generating new genotypes
    ## Generate Ng new genotypes (expected phenotypes) 
    mu <- log(expected.trait^2 / sqrt(Vg+expected.trait^2))
    sigma <- sqrt(log(Vg/expected.trait^2 + 1))
    genotypic.means <- rlnorm(Ng, meanlog=mu, sdlog=sigma)
     ## If length(Ni) = Ng, generate Ni[j] individuals per genotype
    if (length(Ni)==Ng)
      lapply(1:Ng, function(j) {
        mu <- log(genotypic.means[j]^2 / sqrt(Ve+genotypic.means[j]^2))
        sigma <- sqrt(log(Ve/genotypic.means[j]^2 + 1))
        data.frame(etrait=genotypic.means[j], itrait=rlnorm(Ni[j], meanlog=mu, sdlog=sigma))
      }) %>% do.call("rbind.data.frame",.) -> results
    else {
      ## Put floor(Ni/Ng) into Ng groups
      Ni.new <- rep(floor(Ni/Ng), Ng)
      ## If Ni is a multiple of Ng, you're done. 
      ## If not, add an individual to each of the first Ni%%Ng groups
      if (Ni%%Ng!=0) Ni.new[1:(Ni%%Ng)] <- Ni.new[1:(Ni%%Ng)]+1
      ## this formulation deals with the possibility that Ni individuals cannot be evenly subdivided into Ng genotypes
      Ni <- Ni.new
      
      lapply(1:Ng, function(j) {
        mu <- log(genotypic.means[j]^2 / sqrt(Ve+genotypic.means[j]^2))
        sigma <- sqrt(log(Ve/genotypic.means[j]^2 + 1))
        data.frame(etrait=genotypic.means[j], itrait=rlnorm(Ni[j], meanlog=mu, sdlog=sigma))
      }) %>% do.call("rbind.data.frame",.) -> results
    }
  }
  else if (is.null(Vg) & !is.null(Ve)) { ## generating individuals of the same genotype (subject to mutation)
    ## does a mutation occur?
    mutate <- FALSE
    if (!is.null(m)) mutate <- (runif(1) < m)
    if (mutate) { ## mutation occurs, so change the expected phenotype of this individual
      mu <- log(expected.trait^2 / sqrt(Vm+expected.trait^2))
      sigma <- sqrt(log(Vm/expected.trait^2 + 1))
      expected.trait <- rlnorm(1, meanlog=mu, sdlog=sigma)
    }
    ## draw new individuals
    mu <- log(expected.trait^2 / sqrt(Ve+expected.trait^2))
    sigma <- sqrt(log(Ve/expected.trait^2 + 1))
    trait <- rlnorm(Ni, meanlog=mu, sdlog=sigma)
    results <- data.frame(etrait=expected.trait, itrait=trait)
  }
  return(results)
}


pick_individuals_norm <- function(expected.trait, Ni, Ve, Ng=NULL, Vg=NULL, m=NULL, Vm=NULL) {
  if (is.null(Vg) & is.null(Ve)) stop("You must specify either Vg or Ve")
  else if (!is.null(Vg) & is.null(Ng)) stop("You must specify a number of genotypes to generate")
  else if (!is.null(Ng) & is.null(Vg)) stop("You must specify an additive genetic variance to generate genotypes")
  
  if (!is.null(m) & is.null(Vm)) stop ("You must specify a mutational variance")
  
  if (!is.null(Vg)) { ## generating new genotypes
    ## Generate Ng new genotypes (expected phenotypes) 
    genotypic.means <- rnorm(Ng, mean=expected.trait, sd=sqrt(Vg))
     ## If length(Ni) = Ng, generate Ni[j] individuals per genotype
    if (length(Ni)==Ng)
      lapply(1:Ng, function(j) {
        data.frame(etrait=genotypic.means[j], itrait=rnorm(Ni[j], mean=genotypic.means[j], sd=sqrt(Ve)))
      }) %>% do.call("rbind.data.frame",.) -> results
    else {
      ## Put floor(Ni/Ng) into Ng groups
      Ni.new <- rep(floor(Ni/Ng), Ng)
      ## If Ni is a multiple of Ng, you're done. 
      ## If not, add an individual to each of the first Ni%%Ng groups
      if (Ni%%Ng!=0) Ni.new[1:(Ni%%Ng)] <- Ni.new[1:(Ni%%Ng)]+1
      ## this formulation deals with the possibility that Ni individuals cannot be evenly subdivided into Ng genotypes
      Ni <- Ni.new
      
      lapply(1:Ng, function(j) {
        data.frame(etrait=genotypic.means[j], itrait=rnorm(Ni[j], mean=genotypic.means[j], sd=sqrt(Ve)))
      }) %>% do.call("rbind.data.frame",.) -> results
    }
  }
  else if (is.null(Vg) & !is.null(Ve)) { ## generating individuals of the same genotype (subject to mutation)
    ## does a mutation occur?
    mutate <- FALSE
    if (!is.null(m)) mutate <- (runif(1) < m)
    if (mutate) { ## mutation occurs, so change the expected phenotype of this individual
      expected.trait <- rlnorm(1, mean=expected.trait, sd=sqrt(Vm))
    }
    ## draw new individuals
    trait <- rnorm(Ni, mean=expected.trait, sd=sqrt(Ve))
    results <- data.frame(etrait=expected.trait, itrait=trait)
  }
  return(results)
}



```

To see whether this function works, I will generate some genotypes and individuals, then carry out one generation of reproduction for all individuals and look at the parent-offspring regression to make sure everything looks good.
```{r}
## specify a heritability and additive genetic variance
h2 = 0.75
Vg = 0.1
## calculate the Ve from these
Ve = Vg*(1-h2)/h2

## specify an initial population-level trait mean
trait <- 2

## specify an initial number of genotypes and individuals
Ng <- 100
Ni <- 1000

## for now, do not specify a mutation rate or mutational variance

## generate the first generation of individuals
gen1 <- pick_individuals(trait, Ni, Ve, Ng, Vg)

## Now, generate a second generation by assuming that each of these individuals reproduces, producing a single offspring
gen2 <- lapply(gen1$etrait, function(t) pick_individuals(t, 1, Ve)) %>% do.call("rbind.data.frame", .)

## plot a parent-offspring regression using the actual genotypes
plot(gen1$itrait, gen2$itrait)
abline(0,1, col=2)

## individuals in gen1 with itrait > etrait should have offspring whose itrait is smaller than their's (on average)
## is that true? It does not appear to be.
diff1 <- gen1$itrait-gen1$etrait
diff2 <- gen2$itrait-gen2$etrait
lm(diff2~diff1) %>% summary

## Try doing this a different way. Generate 1000 individuals, all with the same expected phenotype. Then generate another 1000, all with the same expected phenotype. Treat the first set as generation 1, and the second set as generation 2. What is the relationship between the phenotypes now?
gen1 <- pick_individuals(2, 1000, Ve)
gen2 <- pick_individuals(2, 1000, Ve)
plot(gen1$itrait, gen2$itrait)
## This looks better

## Essentially no relationship between the actual phenotype of the parent and the actual phenotype of the offspring, which is as it should be
lm(gen2$itrait~gen1$itrait) %>% summary

## generate the first generation of individuals
gen1 <- pick_individuals(trait, Ni, Ve, Ng, Vg)
## Now, generate a second generation by assuming that each of these individuals reproduces, producing a single offspring
gen2 <- lapply(gen1$etrait, function(t) pick_individuals(t, 1, Ve)) %>% do.call("rbind.data.frame", .)

## Compute the genetic and total phenotypic variance in each generation, and the heritability
var(gen1$etrait)
var(gen1$itrait)
var(gen1$etrait)/var(gen1$itrait) ## this is pretty close to the expected heritability

## What is happening is that the individuals who have big expected phenotypes are expected to have big offspring, and that overwhelms the fact that large individuals tend to have smaller offspring. Or maybe the problem is that we're working with a lognormal, rather than normal, distribution?




## generate the first generation of individuals
gen1 <- pick_individuals_norm(trait, Ni, Ve, Ng, Vg)
plot(gen1$etrait, gen1$itrait)
abline(0,1, col=2)

## Now, generate a second generation by assuming that each of these individuals reproduces, producing a single offspring
gen2 <- lapply(gen1$etrait, function(t) pick_individuals_norm(t, 1, Ve)) %>% do.call("rbind.data.frame", .)

## plot a parent-offspring regression using the actual genotypes
## This actually works! The slope of the regression is 0.75, as it should be.
## So the problem is with the lognormal distribution. Heritability is not Vg/(Ve+Vg) if the traits are not normally distributed.
plot(gen1$itrait, gen2$itrait)
abline(0,1, col=2)
lm(gen2$itrait~gen1$itrait) %>% summary

## Maybe this is because the variance of a lognormally distributed trait is not actually Vg, but depends on the mean.

```
