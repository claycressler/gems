---
title: "GEMs with true genotypes"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
```

I want to consider putting actual genotypes into a GEM. 
How would that work?
The easiest way, I think, is to allow users to specify the additive genetic variance in the evolving trait and an initial number of individuals.
For simplicity, and to make the new version most parallel with the old version, each individual will be assumed to have a unique genotype.
Thus, each genotype is characterized by what I will call an "expected phenotype."
The user can also specify a heritability that determines how "faithfully" a genotype passes on its expected phenotype.
When heritability is 1, offspring inherit the phenotype of their parent, which is by definition equal to the expected phenotype of the parent's genotype.
If, however, heritability is less than one, then offspring have a phenotype that is different from the expected phenotype, given their genotype.
That is, each individual is actually characterized by two traits: the phenotype they have (which determines their ecological interactions), and the phenotype they were expected to have, given their genotype.
What each individual passes on when they reproduce is not their *actual* phenotype, but their *expected* phenotype.
How do we use the user-specified heritability and initial additive genetic variance to generate new individuals?
We rely on the definition of heritability as the proportion of total phenotypic variance that is due to additive genetic variance: $H^2 = V_g/(V_g+V_e)$, where $V_g$ is the additive genetic variance and $V_e$ is the phenotypic variance due to the "environment."
Thus, given a heritability and initial additive genetic variance, we can calculate the phenotypic variance that is not heritable.
Then when an individual gives birth, the phenotype of its offspring is determined by drawing from a distribution with a mean equal to the genotypic mean, and variance given by $V_e$.
For evolution to occur in this new version of GEM, we have to a way to generate novel genetic variation.
We do this by the inclusion of a mutation rate: when an individual reproduces, with some small probability, its expected (genotypic) phenotype can change.
It's new expected phenotype is given by drawing from a distribution with mean equal to the current expected genotypic mean, and variance given by the mutational variance.
So the new model is entirely specified by a new "pick_individuals" function.
The function will be slightly flexible to accomodate whether the user is generating new *genotypes* (in which case, the user must specify an additive genetic variance $V_g$) or new *individuals* (in which case, the user must specify an environmental variance $V_e$, a probability of mutation $\mu$, and a mutational variance $V_\mu$). 
In R, this can be achieved by the following:
```{r}
## expected.trait is the expected phenotype of the individuals to generate
## 
## Ni is the total number of individuals to generate with expected.trait. Ni can be a single number or it can be a vector of length Ng.
## In the latter case, the function will generate Ni[j] individuals of each genotype j. In the former case, if Ng!=NULL then the Ni
## individuals will be spread evenly across the Ng genotypes.
## 
## Ve is the phenotypic variance that cannot be attributed to genotype
##
## Ng is the number of genotypes to generate. If Ng!=NULL, Vg must also be specified. 
##
## Vg is the additive genetic variance. If Vg!=NULL, Ng must also be specified.
## 
## m is the probability of mutation. If m!=NULL, Vm must also be specified.
##
## Vm is the variance in phenotypes generated by mutation. 
## 
## If both or neither Vg and Ve are specified, the function returns with a warning
##
## If Ve!=NULL and mu=Vmu=NULL, then mutation cannot occur and the only evolution that can happen is through the fluctuating of initial genotypes
##
## The function returns an array with Ni rows and two columns:
## (1) the first column gives the expected phenotype of the individual (i.e., its genotype); 
## (2) the second column gives the actual phenotype of the individual
## 
pick_individuals <- function(expected.trait, Ni, Ve, Ng=NULL, Vg=NULL, m=NULL, Vm=NULL) {
  if (is.null(Vg) & is.null(Ve)) stop("You must specify either Vg or Ve")
  else if (!is.null(Vg) & is.null(Ng)) stop("You must specify a number of genotypes to generate")
  else if (!is.null(Ng) & is.null(Vg)) stop("You must specify an additive genetic variance to generate genotypes")
  
  if (!is.null(m) & is.null(Vm)) stop ("You must specify a mutational variance")
  
  if (!is.null(Vg)) { ## generating new genotypes
    ## Generate Ng new genotypes (expected phenotypes) 
    mu <- log(expected.trait^2 / sqrt(Vg+expected.trait^2))
    sigma <- sqrt(log(Vg/expected.trait^2 + 1))
    genotypic.means <- rlnorm(Ng, meanlog=mu, sdlog=sigma)
     ## If length(Ni) = Ng, generate Ni[j] individuals per genotype
    if (length(Ni)==Ng)
      lapply(1:Ng, function(j) {
        mu <- log(genotypic.means[j]^2 / sqrt(Ve+genotypic.means[j]^2))
        sigma <- sqrt(log(Ve/genotypic.means[j]^2 + 1))
        data.frame(etrait=genotypic.means[j], itrait=rlnorm(Ni[j], meanlog=mu, sdlog=sigma))
      }) %>% do.call("rbind.data.frame",.) -> results
    else {
      ## Put floor(Ni/Ng) into Ng groups
      Ni.new <- rep(floor(Ni/Ng), Ng)
      ## If Ni is a multiple of Ng, you're done. 
      ## If not, add an individual to each of the first Ni%%Ng groups
      if (Ni%%Ng!=0) Ni.new[1:(Ni%%Ng)] <- Ni.new[1:(Ni%%Ng)]+1
      ## this formulation deals with the possibility that Ni individuals cannot be evenly subdivided into Ng genotypes
      Ni <- Ni.new
      
      lapply(1:Ng, function(j) {
        mu <- log(genotypic.means[j]^2 / sqrt(Ve+genotypic.means[j]^2))
        sigma <- sqrt(log(Ve/genotypic.means[j]^2 + 1))
        data.frame(etrait=genotypic.means[j], itrait=rlnorm(Ni[j], meanlog=mu, sdlog=sigma))
      }) %>% do.call("rbind.data.frame",.) -> results
    }
  }
  else if (is.null(Vg) & !is.null(Ve)) { ## generating individuals of the same genotype (subject to mutation)
    ## does a mutation occur?
    mutate <- FALSE
    if (!is.null(m)) mutate <- (runif(1) < m)
    if (mutate) { ## mutation occurs, so change the expected phenotype of this individual
      mu <- log(expected.trait^2 / sqrt(Vm+expected.trait^2))
      sigma <- sqrt(log(Vm/expected.trait^2 + 1))
      expected.trait <- rlnorm(1, meanlog=mu, sdlog=sigma)
    }
    ## draw new individuals
    mu <- log(expected.trait^2 / sqrt(Ve+expected.trait^2))
    sigma <- sqrt(log(Ve/expected.trait^2 + 1))
    trait <- rlnorm(Ni, meanlog=mu, sdlog=sigma)
    results <- data.frame(etrait=expected.trait, itrait=trait)
  }
  return(results)
}



```

To see whether this function works, I will generate some genotypes and individuals. 
Fig. 1 shows the results of generating 1000 individuals, across 50 genotypes, assuming a lognormally distributed trait with mean 2, additive genetic variance $V_g=0.1$, and heritability $h^2=V_g/(V_e+V_g)=0.75$ (yielding a non-genetic phenotypic variance $V_e = 0.0133$).

```{r, fig.height=4, fig.width=4, units='in', res=300, fig.cap="The relationship between expected phenotype (i.e., the genotype) and the actual phenotypes of 1000 individuals across 50 genotypes."}
## specify a heritability and additive genetic variance
h2 = 0.75
Vg = 0.1
## calculate the Ve from these
Ve = Vg*(1-h2)/h2

## specify an initial population-level trait mean
trait <- 2

## specify an initial number of genotypes and individuals
Ng <- 50
Ni <- 1000

## for now, do not specify a mutation rate or mutational variance

## generate the first generation of individuals
gen1 <- pick_individuals(trait, Ni, Ve, Ng, Vg)
plot(gen1$etrait, gen1$itrait, xlab="Expected phenotype", ylab="Actual phenotype")

```

To verify that the heritability is functioning as expected, I will compute the heritability in a slightly different way: as the slope of a parent-offspring regression.
Since heritability is less than 1, individuals will be born with phenotypes that are larger or smaller than expected.
However, across generations, individuals with larger-than-expected phenotypes will give birth to offspring with traits a bit closer to the expectation, as will individuals with smaller-than-expected phenotypes.
This 'regression to the mean' will produce a parent-offspring regression with a slope less than one: in particular, this slope is another way to measure heritability, and so it should be close to 0.75 (in this case).
To test this, I will use the individuals generated above as the parents of a new generation of offspring, and I will regress the actual (not expected) phenotypes of the parents against the actual phenotypes of the offspring.
Fig. 2 shows the results, confirming that the regression slope is similar to the heritability (any discrepancy is just due to noise - for example, if you increase to 100,000 individuals across 1,000 genotypes, the slope of the regression is *exactly* 0.75, as expected).
```{r, fig.height=4, fig.width=4, units='in', res=300, fig.cap="Parent-offspring regression for a The solid blue line gives the one-to-one line, and the dashed orange line gives the results of a regression of the parental phenotype on the offspring phenotype (the text gives the slope of this regression line)."}

gen2 <- lapply(gen1$etrait, function(t) pick_individuals(t, 1, Ve)) %>% do.call("rbind.data.frame", .)

## plot a parent-offspring regression using the actual genotypes
plot(gen1$itrait, gen2$itrait, xlab='Parent', ylab='Offspring')
abline(0,1, col='lightblue', lwd=2)
abline(lm(gen2$itrait~gen1$itrait), col='orange', lwd=2, lty=2)
legend(x='topleft', paste0('slope=',signif(coef(lm(gen2$itrait~gen1$itrait))[2],2)), bty='n')

# gen1 <- pick_individuals(trait, 1e5, Ve, 1e3, Vg)
# gen2 <- lapply(gen1$etrait, function(t) pick_individuals(t, 1, Ve)) %>% do.call("rbind.data.frame", .)
# signif(coef(lm(gen2$itrait~gen1$itrait))[2],2)

```

Just to fully verify that this is working, here are the results of parent-offspring regressions for 10,000 individuals across 100 genotypes, with heritabilities ranging from 0.1 to 0.9.
```{r, fig.height=6, fig.width=6, units='in', res=300, fig.cap="Parent-offspring regressions for varying heritabilities."}
par(mfrow=c(3,3), mar=c(2,2,0.5,0.5), oma=c(2,2,0,0))
for (h in seq(0.1,0.9,0.1)) {
  ## specify a heritability and additive genetic variance
  h2 = h
  Vg = 0.1
  ## calculate the Ve from these
  Ve = Vg*(1-h2)/h2

  ## specify an initial population-level trait mean
  trait <- 2
  
  ## specify an initial number of genotypes and individuals
  Ng <- 100
  Ni <- 10000

  ## generate the first generation of individuals
  gen1 <- pick_individuals(trait, Ni, Ve, Ng, Vg)
  gen2 <- lapply(gen1$etrait, function(t) pick_individuals(t, 1, Ve)) %>% do.call("rbind.data.frame", .)
  plot(gen1$itrait, gen2$itrait, xlab='', ylab='')
abline(0,1, col='lightblue', lwd=2)
abline(lm(gen2$itrait~gen1$itrait), col='orange', lwd=2, lty=2)
legend(x='topleft', paste0('slope=',signif(coef(lm(gen2$itrait~gen1$itrait))[2],2)), bty='n')
}
mtext(side=1, outer=TRUE, "Parent")
mtext(side=2, outer=TRUE, "Offspring")
  
```


```{r}

pick_individuals_norm <- function(expected.trait, Ni, Ve, Ng=NULL, Vg=NULL, m=NULL, Vm=NULL) {
  if (is.null(Vg) & is.null(Ve)) stop("You must specify either Vg or Ve")
  else if (!is.null(Vg) & is.null(Ng)) stop("You must specify a number of genotypes to generate")
  else if (!is.null(Ng) & is.null(Vg)) stop("You must specify an additive genetic variance to generate genotypes")
  
  if (!is.null(m) & is.null(Vm)) stop ("You must specify a mutational variance")
  
  if (!is.null(Vg)) { ## generating new genotypes
    ## Generate Ng new genotypes (expected phenotypes) 
    genotypic.means <- rnorm(Ng, mean=expected.trait, sd=sqrt(Vg))
     ## If length(Ni) = Ng, generate Ni[j] individuals per genotype
    if (length(Ni)==Ng)
      lapply(1:Ng, function(j) {
        data.frame(etrait=genotypic.means[j], itrait=rnorm(Ni[j], mean=genotypic.means[j], sd=sqrt(Ve)))
      }) %>% do.call("rbind.data.frame",.) -> results
    else {
      ## Put floor(Ni/Ng) into Ng groups
      Ni.new <- rep(floor(Ni/Ng), Ng)
      ## If Ni is a multiple of Ng, you're done. 
      ## If not, add an individual to each of the first Ni%%Ng groups
      if (Ni%%Ng!=0) Ni.new[1:(Ni%%Ng)] <- Ni.new[1:(Ni%%Ng)]+1
      ## this formulation deals with the possibility that Ni individuals cannot be evenly subdivided into Ng genotypes
      Ni <- Ni.new
      
      lapply(1:Ng, function(j) {
        data.frame(etrait=genotypic.means[j], itrait=rnorm(Ni[j], mean=genotypic.means[j], sd=sqrt(Ve)))
      }) %>% do.call("rbind.data.frame",.) -> results
    }
  }
  else if (is.null(Vg) & !is.null(Ve)) { ## generating individuals of the same genotype (subject to mutation)
    ## does a mutation occur?
    mutate <- FALSE
    if (!is.null(m)) mutate <- (runif(1) < m)
    if (mutate) { ## mutation occurs, so change the expected phenotype of this individual
      expected.trait <- rlnorm(1, mean=expected.trait, sd=sqrt(Vm))
    }
    ## draw new individuals
    trait <- rnorm(Ni, mean=expected.trait, sd=sqrt(Ve))
    results <- data.frame(etrait=expected.trait, itrait=trait)
  }
  return(results)
}

```